"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * timelight
 * This is the timelight api.
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const portableFetch = require("portable-fetch");
const BASE_PATH = "http://localhost".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace AlertDto
 */
var AlertDto;
(function (AlertDto) {
    /**
     * @export
     * @enum {string}
     */
    let ActivityEnum;
    (function (ActivityEnum) {
        ActivityEnum[ActivityEnum["Over"] = 'over'] = "Over";
        ActivityEnum[ActivityEnum["Under"] = 'under'] = "Under";
    })(ActivityEnum = AlertDto.ActivityEnum || (AlertDto.ActivityEnum = {}));
})(AlertDto = exports.AlertDto || (exports.AlertDto = {}));
/**
 * @export
 * @namespace AlertRefDto
 */
var AlertRefDto;
(function (AlertRefDto) {
    /**
     * @export
     * @enum {string}
     */
    let ActivityEnum;
    (function (ActivityEnum) {
        ActivityEnum[ActivityEnum["Over"] = 'over'] = "Over";
        ActivityEnum[ActivityEnum["Under"] = 'under'] = "Under";
    })(ActivityEnum = AlertRefDto.ActivityEnum || (AlertRefDto.ActivityEnum = {}));
})(AlertRefDto = exports.AlertRefDto || (exports.AlertRefDto = {}));
/**
 * @export
 * @namespace DayContext
 */
var DayContext;
(function (DayContext) {
    /**
     * @export
     * @enum {string}
     */
    let CtxTypeEnum;
    (function (CtxTypeEnum) {
        CtxTypeEnum[CtxTypeEnum["Dju"] = 'dju'] = "Dju";
        CtxTypeEnum[CtxTypeEnum["TempMaxDeg"] = 'temp_max_deg'] = "TempMaxDeg";
        CtxTypeEnum[CtxTypeEnum["TempMinDeg"] = 'temp_min_deg'] = "TempMinDeg";
        CtxTypeEnum[CtxTypeEnum["WindSpeedKmh"] = 'wind_speed_kmh'] = "WindSpeedKmh";
        CtxTypeEnum[CtxTypeEnum["WindTempDeg"] = 'wind_temp_deg'] = "WindTempDeg";
        CtxTypeEnum[CtxTypeEnum["RainMm"] = 'rain_mm'] = "RainMm";
        CtxTypeEnum[CtxTypeEnum["HumidityPerc"] = 'humidity_perc'] = "HumidityPerc";
        CtxTypeEnum[CtxTypeEnum["VisibilityKm"] = 'visibility_km'] = "VisibilityKm";
        CtxTypeEnum[CtxTypeEnum["CloudCoverPerc"] = 'cloud_cover_perc'] = "CloudCoverPerc";
        CtxTypeEnum[CtxTypeEnum["HeatIdxUnit"] = 'heat_idx_unit'] = "HeatIdxUnit";
        CtxTypeEnum[CtxTypeEnum["DewPointDeg"] = 'dew_point_deg'] = "DewPointDeg";
        CtxTypeEnum[CtxTypeEnum["PressureHpa"] = 'pressure_hpa'] = "PressureHpa";
        CtxTypeEnum[CtxTypeEnum["SunriseSec"] = 'sunrise_sec'] = "SunriseSec";
        CtxTypeEnum[CtxTypeEnum["SunsetSec"] = 'sunset_sec'] = "SunsetSec";
        CtxTypeEnum[CtxTypeEnum["DayLengthSec"] = 'day_length_sec'] = "DayLengthSec";
        CtxTypeEnum[CtxTypeEnum["HistoriqueMeteoEnum"] = 'historique_meteo_enum'] = "HistoriqueMeteoEnum";
    })(CtxTypeEnum = DayContext.CtxTypeEnum || (DayContext.CtxTypeEnum = {}));
})(DayContext = exports.DayContext || (exports.DayContext = {}));
/**
 * @export
 * @namespace DayTrend
 */
var DayTrend;
(function (DayTrend) {
    /**
     * @export
     * @enum {string}
     */
    let UnitEnum;
    (function (UnitEnum) {
        UnitEnum[UnitEnum["Percent"] = 'percent'] = "Percent";
        UnitEnum[UnitEnum["Unit"] = 'unit'] = "Unit";
    })(UnitEnum = DayTrend.UnitEnum || (DayTrend.UnitEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["OneShot"] = 'one-shot'] = "OneShot";
        TypeEnum[TypeEnum["Weekly"] = 'weekly'] = "Weekly";
        TypeEnum[TypeEnum["Monthly"] = 'monthly'] = "Monthly";
    })(TypeEnum = DayTrend.TypeEnum || (DayTrend.TypeEnum = {}));
})(DayTrend = exports.DayTrend || (exports.DayTrend = {}));
/**
 * @export
 * @namespace DayTrendInput
 */
var DayTrendInput;
(function (DayTrendInput) {
    /**
     * @export
     * @enum {string}
     */
    let UnitEnum;
    (function (UnitEnum) {
        UnitEnum[UnitEnum["Percent"] = 'percent'] = "Percent";
        UnitEnum[UnitEnum["Unit"] = 'unit'] = "Unit";
    })(UnitEnum = DayTrendInput.UnitEnum || (DayTrendInput.UnitEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["OneShot"] = 'one-shot'] = "OneShot";
        TypeEnum[TypeEnum["Weekly"] = 'weekly'] = "Weekly";
        TypeEnum[TypeEnum["Monthly"] = 'monthly'] = "Monthly";
    })(TypeEnum = DayTrendInput.TypeEnum || (DayTrendInput.TypeEnum = {}));
})(DayTrendInput = exports.DayTrendInput || (exports.DayTrendInput = {}));
/**
 * AIApi - fetch parameter creator
 * @export
 */
exports.AIApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Auto detect-anomalies
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1AiAnomaliesSourceIdGet.');
            }
            const localVarPath = `/v1/ai/anomalies/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1AiRecomputeDayModelsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1AiRecomputeDayModelsSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-day-models/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1AiRecomputeDaysProjectionSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1AiRecomputeDaysProjectionSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-days-projection/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year
         * @param {number} sourceId
         * @param {number} [modelCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1AiRecomputeModelsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1AiRecomputeModelsSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-models/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (modelCount !== undefined) {
                localVarQueryParameter['modelCount'] = modelCount;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount, options = {}) {
            // verify required parameter 'modelCount' is not null or undefined
            if (modelCount === null || modelCount === undefined) {
                throw new RequiredError('modelCount', 'Required parameter modelCount was null or undefined when calling v1AiRecomputeSourceModelsModelCountPost.');
            }
            const localVarPath = `/v1/ai/recompute-source-models/{modelCount}`
                .replace(`{${"modelCount"}}`, encodeURIComponent(String(modelCount)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AIApi - functional programming interface
 * @export
 */
exports.AIApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Auto detect-anomalies
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId, options) {
            const localVarFetchArgs = exports.AIApiFetchParamCreator(configuration).v1AiAnomaliesSourceIdGet(sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options) {
            const localVarFetchArgs = exports.AIApiFetchParamCreator(configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options) {
            const localVarFetchArgs = exports.AIApiFetchParamCreator(configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year
         * @param {number} sourceId
         * @param {number} [modelCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options) {
            const localVarFetchArgs = exports.AIApiFetchParamCreator(configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount, options) {
            const localVarFetchArgs = exports.AIApiFetchParamCreator(configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AIApi - factory interface
 * @export
 */
exports.AIApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Auto detect-anomalies
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId, options) {
            return exports.AIApiFp(configuration).v1AiAnomaliesSourceIdGet(sourceId, options)(fetch, basePath);
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options) {
            return exports.AIApiFp(configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options) {
            return exports.AIApiFp(configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year
         * @param {number} sourceId
         * @param {number} [modelCount]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options) {
            return exports.AIApiFp(configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options)(fetch, basePath);
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount, options) {
            return exports.AIApiFp(configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options)(fetch, basePath);
        },
    };
};
/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
class AIApi extends BaseAPI {
    /**
     *
     * @summary Auto detect-anomalies
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    v1AiAnomaliesSourceIdGet(sourceId, options) {
        return exports.AIApiFp(this.configuration).v1AiAnomaliesSourceIdGet(sourceId, options)(this.fetch, this.basePath);
    }
    /**
     * Erases and re-computes all day models for a source and year
     * @summary Recomputes all day modesl
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options) {
        return exports.AIApiFp(this.configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     * This computes the X/Y projection of all days in the source for the given year
     * @summary Computes all days projection for a source and save them
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options) {
        return exports.AIApiFp(this.configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     * This operations erases both non-handled alerts and user previsions
     * @summary Triggers a model recompute
     * @param {number} year
     * @param {number} sourceId
     * @param {number} [modelCount]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options) {
        return exports.AIApiFp(this.configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options)(this.fetch, this.basePath);
    }
    /**
     * This operations erases the group configuration
     * @summary Triggers a model recompute for source groups
     * @param {number} modelCount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    v1AiRecomputeSourceModelsModelCountPost(modelCount, options) {
        return exports.AIApiFp(this.configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options)(this.fetch, this.basePath);
    }
}
exports.AIApi = AIApi;
/**
 * AlertApi - fetch parameter creator
 * @export
 */
exports.AlertApiFetchParamCreator = function (configuration) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options = {}) {
            // verify required parameter 'AlertCommentDto' is not null or undefined
            if (AlertCommentDto === null || AlertCommentDto === undefined) {
                throw new RequiredError('AlertCommentDto', 'Required parameter AlertCommentDto was null or undefined when calling v1AlertAlertIdCommentPatch.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId', 'Required parameter alertId was null or undefined when calling v1AlertAlertIdCommentPatch.');
            }
            const localVarPath = `/v1/alert/{alertId}/comment`
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AlertCommentDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(AlertCommentDto || {}) : (AlertCommentDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options = {}) {
            // verify required parameter 'AlertFavoriteDto' is not null or undefined
            if (AlertFavoriteDto === null || AlertFavoriteDto === undefined) {
                throw new RequiredError('AlertFavoriteDto', 'Required parameter AlertFavoriteDto was null or undefined when calling v1AlertAlertIdFavoritePatch.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId', 'Required parameter alertId was null or undefined when calling v1AlertAlertIdFavoritePatch.');
            }
            const localVarPath = `/v1/alert/{alertId}/favorite`
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AlertFavoriteDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(AlertFavoriteDto || {}) : (AlertFavoriteDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId, year, options = {}) {
            const localVarPath = `/v1/alert/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }
            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId, year, options = {}) {
            const localVarPath = `/v1/alert/ref/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }
            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AlertApi - functional programming interface
 * @export
 */
exports.AlertApiFp = function (configuration) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options) {
            const localVarFetchArgs = exports.AlertApiFetchParamCreator(configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options) {
            const localVarFetchArgs = exports.AlertApiFetchParamCreator(configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId, year, options) {
            const localVarFetchArgs = exports.AlertApiFetchParamCreator(configuration).v1AlertListGet(sourceId, year, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId, year, options) {
            const localVarFetchArgs = exports.AlertApiFetchParamCreator(configuration).v1AlertRefListGet(sourceId, year, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AlertApi - factory interface
 * @export
 */
exports.AlertApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options) {
            return exports.AlertApiFp(configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto
         * @param {number} alertId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options) {
            return exports.AlertApiFp(configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options)(fetch, basePath);
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId, year, options) {
            return exports.AlertApiFp(configuration).v1AlertListGet(sourceId, year, options)(fetch, basePath);
        },
        /**
         *
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId]
         * @param {number} [year]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId, year, options) {
            return exports.AlertApiFp(configuration).v1AlertRefListGet(sourceId, year, options)(fetch, basePath);
        },
    };
};
/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
class AlertApi extends BaseAPI {
    /**
     * A commented alert is closed and is moved to the alert referential
     * @summary Add a comment to an alert
     * @param {AlertCommentDto} AlertCommentDto
     * @param {number} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options) {
        return exports.AlertApiFp(this.configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Set alert favorite for the current user
     * @param {AlertFavoriteDto} AlertFavoriteDto
     * @param {number} alertId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options) {
        return exports.AlertApiFp(this.configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary List alerts data of the selected year, all alerts if no year is provided
     * @param {number} [sourceId]
     * @param {number} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    v1AlertListGet(sourceId, year, options) {
        return exports.AlertApiFp(this.configuration).v1AlertListGet(sourceId, year, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary List alerts data of the selected year, all alerts if no year is provided
     * @param {number} [sourceId]
     * @param {number} [year]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    v1AlertRefListGet(sourceId, year, options) {
        return exports.AlertApiFp(this.configuration).v1AlertRefListGet(sourceId, year, options)(this.fetch, this.basePath);
    }
}
exports.AlertApi = AlertApi;
/**
 * DayApi - fetch parameter creator
 * @export
 */
exports.DayApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto, options = {}) {
            // verify required parameter 'DaysPatchDto' is not null or undefined
            if (DaysPatchDto === null || DaysPatchDto === undefined) {
                throw new RequiredError('DaysPatchDto', 'Required parameter DaysPatchDto was null or undefined when calling v1DayBulkPatch.');
            }
            const localVarPath = `/v1/day/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DaysPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DaysPatchDto || {}) : (DaysPatchDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List day data of the reference year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1DayListSourceIdYearGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1DayListSourceIdYearGet.');
            }
            const localVarPath = `/v1/day/list/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DayApi - functional programming interface
 * @export
 */
exports.DayApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto, options) {
            const localVarFetchArgs = exports.DayApiFetchParamCreator(configuration).v1DayBulkPatch(DaysPatchDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List day data of the reference year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year, sourceId, options) {
            const localVarFetchArgs = exports.DayApiFetchParamCreator(configuration).v1DayListSourceIdYearGet(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DayApi - factory interface
 * @export
 */
exports.DayApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto, options) {
            return exports.DayApiFp(configuration).v1DayBulkPatch(DaysPatchDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary List day data of the reference year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year, sourceId, options) {
            return exports.DayApiFp(configuration).v1DayListSourceIdYearGet(year, sourceId, options)(fetch, basePath);
        },
    };
};
/**
 * DayApi - object-oriented interface
 * @export
 * @class DayApi
 * @extends {BaseAPI}
 */
class DayApi extends BaseAPI {
    /**
     *
     * @summary Update day entities
     * @param {DaysPatchDto} DaysPatchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayApi
     */
    v1DayBulkPatch(DaysPatchDto, options) {
        return exports.DayApiFp(this.configuration).v1DayBulkPatch(DaysPatchDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary List day data of the reference year
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayApi
     */
    v1DayListSourceIdYearGet(year, sourceId, options) {
        return exports.DayApiFp(this.configuration).v1DayListSourceIdYearGet(year, sourceId, options)(this.fetch, this.basePath);
    }
}
exports.DayApi = DayApi;
/**
 * DayContextApi - fetch parameter creator
 * @export
 */
exports.DayContextApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto, options = {}) {
            // verify required parameter 'GeneratedDayContextBulkDto' is not null or undefined
            if (GeneratedDayContextBulkDto === null || GeneratedDayContextBulkDto === undefined) {
                throw new RequiredError('GeneratedDayContextBulkDto', 'Required parameter GeneratedDayContextBulkDto was null or undefined when calling v1DayContextBulkPost.');
            }
            const localVarPath = `/v1/day-context/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("GeneratedDayContextBulkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(GeneratedDayContextBulkDto || {}) : (GeneratedDayContextBulkDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options = {}) {
            const localVarPath = `/v1/day-context`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }
            if (or !== undefined) {
                localVarQueryParameter['or'] = or;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }
            if (per_page !== undefined) {
                localVarQueryParameter['per_page'] = per_page;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete one DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayContextIdDelete.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve one DayContext
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id, fields, join, cache, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayContextIdGet.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }
            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext, id, options = {}) {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext', 'Required parameter DayContext was null or undefined when calling v1DayContextIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayContextIdPatch.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext, id, options = {}) {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext', 'Required parameter DayContext was null or undefined when calling v1DayContextIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayContextIdPut.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1DayContextImportMeteoCsvSourceIdPost.');
            }
            const localVarPath = `/v1/day-context/import-meteo-csv/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create one DayContext
         * @param {DayContext} DayContext
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext, options = {}) {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext', 'Required parameter DayContext was null or undefined when calling v1DayContextPost.');
            }
            const localVarPath = `/v1/day-context`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DayContextApi - functional programming interface
 * @export
 */
exports.DayContextApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete one DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextIdDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve one DayContext
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id, fields, join, cache, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextIdGet(id, fields, join, cache, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext, id, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextIdPatch(DayContext, id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext, id, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextIdPut(DayContext, id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create one DayContext
         * @param {DayContext} DayContext
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext, options) {
            const localVarFetchArgs = exports.DayContextApiFetchParamCreator(configuration).v1DayContextPost(DayContext, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DayContextApi - factory interface
 * @export
 */
exports.DayContextApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto, options) {
            return exports.DayContextApiFp(configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
            return exports.DayContextApiFp(configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete one DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id, options) {
            return exports.DayContextApiFp(configuration).v1DayContextIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve one DayContext
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id, fields, join, cache, options) {
            return exports.DayContextApiFp(configuration).v1DayContextIdGet(id, fields, join, cache, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext, id, options) {
            return exports.DayContextApiFp(configuration).v1DayContextIdPatch(DayContext, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace one DayContext
         * @param {DayContext} DayContext
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext, id, options) {
            return exports.DayContextApiFp(configuration).v1DayContextIdPut(DayContext, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId, options) {
            return exports.DayContextApiFp(configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create one DayContext
         * @param {DayContext} DayContext
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext, options) {
            return exports.DayContextApiFp(configuration).v1DayContextPost(DayContext, options)(fetch, basePath);
        },
    };
};
/**
 * DayContextApi - object-oriented interface
 * @export
 * @class DayContextApi
 * @extends {BaseAPI}
 */
class DayContextApi extends BaseAPI {
    /**
     *
     * @summary Create many DayContext
     * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextBulkPost(GeneratedDayContextBulkDto, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Retrieve many DayContext
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
     * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
     * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
     * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete one DayContext
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextIdDelete(id, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextIdDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Retrieve one DayContext
     * @param {number} id
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextIdGet(id, fields, join, cache, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextIdGet(id, fields, join, cache, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update one DayContext
     * @param {DayContext} DayContext
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextIdPatch(DayContext, id, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextIdPatch(DayContext, id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace one DayContext
     * @param {DayContext} DayContext
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextIdPut(DayContext, id, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextIdPut(DayContext, id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Imports a meteo csv file for the source id
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextImportMeteoCsvSourceIdPost(sourceId, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create one DayContext
     * @param {DayContext} DayContext
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    v1DayContextPost(DayContext, options) {
        return exports.DayContextApiFp(this.configuration).v1DayContextPost(DayContext, options)(this.fetch, this.basePath);
    }
}
exports.DayContextApi = DayContextApi;
/**
 * DayTrendApi - fetch parameter creator
 * @export
 */
exports.DayTrendApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options = {}) {
            // verify required parameter 'GeneratedDayTrendBulkDto' is not null or undefined
            if (GeneratedDayTrendBulkDto === null || GeneratedDayTrendBulkDto === undefined) {
                throw new RequiredError('GeneratedDayTrendBulkDto', 'Required parameter GeneratedDayTrendBulkDto was null or undefined when calling v1DayTrendBulkPost.');
            }
            const localVarPath = `/v1/day-trend/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("GeneratedDayTrendBulkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(GeneratedDayTrendBulkDto || {}) : (GeneratedDayTrendBulkDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options = {}) {
            const localVarPath = `/v1/day-trend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }
            if (or !== undefined) {
                localVarQueryParameter['or'] = or;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }
            if (per_page !== undefined) {
                localVarQueryParameter['per_page'] = per_page;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete one DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayTrendIdDelete.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve one DayTrend
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id, fields, join, cache, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayTrendIdGet.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }
            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend, id, options = {}) {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend', 'Required parameter DayTrend was null or undefined when calling v1DayTrendIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayTrendIdPatch.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend, id, options = {}) {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend', 'Required parameter DayTrend was null or undefined when calling v1DayTrendIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling v1DayTrendIdPut.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend, options = {}) {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend', 'Required parameter DayTrend was null or undefined when calling v1DayTrendPost.');
            }
            const localVarPath = `/v1/day-trend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId
         * @param {DayTrendInputListDto} DayTrendInputListDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1DayTrendReplaceAllInSourceSourceIdPost.');
            }
            // verify required parameter 'DayTrendInputListDto' is not null or undefined
            if (DayTrendInputListDto === null || DayTrendInputListDto === undefined) {
                throw new RequiredError('DayTrendInputListDto', 'Required parameter DayTrendInputListDto was null or undefined when calling v1DayTrendReplaceAllInSourceSourceIdPost.');
            }
            const localVarPath = `/v1/day-trend/replace-all-in-source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DayTrendInputListDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(DayTrendInputListDto || {}) : (DayTrendInputListDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DayTrendApi - functional programming interface
 * @export
 */
exports.DayTrendApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete one DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendIdDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Retrieve one DayTrend
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id, fields, join, cache, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendIdGet(id, fields, join, cache, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend, id, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendIdPatch(DayTrend, id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend, id, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendIdPut(DayTrend, id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendPost(DayTrend, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId
         * @param {DayTrendInputListDto} DayTrendInputListDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options) {
            const localVarFetchArgs = exports.DayTrendApiFetchParamCreator(configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * DayTrendApi - factory interface
 * @export
 */
exports.DayTrendApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete one DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendIdDelete(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Retrieve one DayTrend
         * @param {number} id
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id, fields, join, cache, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendIdGet(id, fields, join, cache, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend, id, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendIdPatch(DayTrend, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend, id, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendIdPut(DayTrend, id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendPost(DayTrend, options)(fetch, basePath);
        },
        /**
         *
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId
         * @param {DayTrendInputListDto} DayTrendInputListDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options) {
            return exports.DayTrendApiFp(configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options)(fetch, basePath);
        },
    };
};
/**
 * DayTrendApi - object-oriented interface
 * @export
 * @class DayTrendApi
 * @extends {BaseAPI}
 */
class DayTrendApi extends BaseAPI {
    /**
     *
     * @summary Create many DayTrend
     * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Retrieve many DayTrend
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
     * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
     * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
     * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete one DayTrend
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendIdDelete(id, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendIdDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Retrieve one DayTrend
     * @param {number} id
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendIdGet(id, fields, join, cache, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendIdGet(id, fields, join, cache, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update one DayTrend
     * @param {DayTrend} DayTrend
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendIdPatch(DayTrend, id, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendIdPatch(DayTrend, id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace one DayTrend
     * @param {DayTrend} DayTrend
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendIdPut(DayTrend, id, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendIdPut(DayTrend, id, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create one DayTrend
     * @param {DayTrend} DayTrend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendPost(DayTrend, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendPost(DayTrend, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Imports many trends and replace existing. Recomputes alerts
     * @param {number} sourceId
     * @param {DayTrendInputListDto} DayTrendInputListDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options) {
        return exports.DayTrendApiFp(this.configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options)(this.fetch, this.basePath);
    }
}
exports.DayTrendApi = DayTrendApi;
/**
 * ImportApi - fetch parameter creator
 * @export
 */
exports.ImportApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto, options = {}) {
            // verify required parameter 'CreateSourceDto' is not null or undefined
            if (CreateSourceDto === null || CreateSourceDto === undefined) {
                throw new RequiredError('CreateSourceDto', 'Required parameter CreateSourceDto was null or undefined when calling v1ImportCreateSourcePost.');
            }
            const localVarPath = `/v1/import/create-source`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CreateSourceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(CreateSourceDto || {}) : (CreateSourceDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto, options = {}) {
            // verify required parameter 'ImportDaysDto' is not null or undefined
            if (ImportDaysDto === null || ImportDaysDto === undefined) {
                throw new RequiredError('ImportDaysDto', 'Required parameter ImportDaysDto was null or undefined when calling v1ImportDaysPost.');
            }
            const localVarPath = `/v1/import/days`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ImportDaysDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(ImportDaysDto || {}) : (ImportDaysDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1ImportReprocessDaysSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1ImportReprocessDaysSourceIdYearPost.');
            }
            const localVarPath = `/v1/import/reprocess-days/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1ImportSourceIdDaysPost.');
            }
            // verify required parameter 'ImportDaysDto' is not null or undefined
            if (ImportDaysDto === null || ImportDaysDto === undefined) {
                throw new RequiredError('ImportDaysDto', 'Required parameter ImportDaysDto was null or undefined when calling v1ImportSourceIdDaysPost.');
            }
            const localVarPath = `/v1/import/{sourceId}/days`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ImportDaysDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(ImportDaysDto || {}) : (ImportDaysDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ImportApi - functional programming interface
 * @export
 */
exports.ImportApiFp = function (configuration) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto, options) {
            const localVarFetchArgs = exports.ImportApiFetchParamCreator(configuration).v1ImportCreateSourcePost(CreateSourceDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto, options) {
            const localVarFetchArgs = exports.ImportApiFetchParamCreator(configuration).v1ImportDaysPost(ImportDaysDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options) {
            const localVarFetchArgs = exports.ImportApiFetchParamCreator(configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options) {
            const localVarFetchArgs = exports.ImportApiFetchParamCreator(configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ImportApi - factory interface
 * @export
 */
exports.ImportApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto, options) {
            return exports.ImportApiFp(configuration).v1ImportCreateSourcePost(CreateSourceDto, options)(fetch, basePath);
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto, options) {
            return exports.ImportApiFp(configuration).v1ImportDaysPost(ImportDaysDto, options)(fetch, basePath);
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options) {
            return exports.ImportApiFp(configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId
         * @param {ImportDaysDto} ImportDaysDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options) {
            return exports.ImportApiFp(configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options)(fetch, basePath);
        },
    };
};
/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
class ImportApi extends BaseAPI {
    /**
     * Creates a source, add a first batch of day data, then computes the models for the first time.
     * @summary First source creation
     * @param {CreateSourceDto} CreateSourceDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    v1ImportCreateSourcePost(CreateSourceDto, options) {
        return exports.ImportApiFp(this.configuration).v1ImportCreateSourcePost(CreateSourceDto, options)(this.fetch, this.basePath);
    }
    /**
     * When new data is added, we compute alerts for this data
     * @summary Add new data to a source
     * @param {ImportDaysDto} ImportDaysDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    v1ImportDaysPost(ImportDaysDto, options) {
        return exports.ImportApiFp(this.configuration).v1ImportDaysPost(ImportDaysDto, options)(this.fetch, this.basePath);
    }
    /**
     * Compute maps, alerts and closest models
     * @summary Reprocess days from database
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options) {
        return exports.ImportApiFp(this.configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     * When new data is added, we compute alerts for this data
     * @summary Add new data to a source
     * @param {number} sourceId
     * @param {ImportDaysDto} ImportDaysDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options) {
        return exports.ImportApiFp(this.configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options)(this.fetch, this.basePath);
    }
}
exports.ImportApi = ImportApi;
/**
 * ModelApi - fetch parameter creator
 * @export
 */
exports.ModelApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto, options = {}) {
            // verify required parameter 'ModelsPatchDto' is not null or undefined
            if (ModelsPatchDto === null || ModelsPatchDto === undefined) {
                throw new RequiredError('ModelsPatchDto', 'Required parameter ModelsPatchDto was null or undefined when calling v1ModelBulkPatch.');
            }
            const localVarPath = `/v1/model/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ModelsPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(ModelsPatchDto || {}) : (ModelsPatchDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary List models data of this source
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1ModelListSourceIdGet.');
            }
            const localVarPath = `/v1/model/list/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ModelApi - functional programming interface
 * @export
 */
exports.ModelApiFp = function (configuration) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto, options) {
            const localVarFetchArgs = exports.ModelApiFetchParamCreator(configuration).v1ModelBulkPatch(ModelsPatchDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary List models data of this source
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId, options) {
            const localVarFetchArgs = exports.ModelApiFetchParamCreator(configuration).v1ModelListSourceIdGet(sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ModelApi - factory interface
 * @export
 */
exports.ModelApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto, options) {
            return exports.ModelApiFp(configuration).v1ModelBulkPatch(ModelsPatchDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary List models data of this source
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId, options) {
            return exports.ModelApiFp(configuration).v1ModelListSourceIdGet(sourceId, options)(fetch, basePath);
        },
    };
};
/**
 * ModelApi - object-oriented interface
 * @export
 * @class ModelApi
 * @extends {BaseAPI}
 */
class ModelApi extends BaseAPI {
    /**
     * Update many models at once, mainly used to set color and name of the model
     * @summary Model bulk update
     * @param {ModelsPatchDto} ModelsPatchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    v1ModelBulkPatch(ModelsPatchDto, options) {
        return exports.ModelApiFp(this.configuration).v1ModelBulkPatch(ModelsPatchDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary List models data of this source
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    v1ModelListSourceIdGet(sourceId, options) {
        return exports.ModelApiFp(this.configuration).v1ModelListSourceIdGet(sourceId, options)(this.fetch, this.basePath);
    }
}
exports.ModelApi = ModelApi;
/**
 * PrevisionApi - fetch parameter creator
 * @export
 */
exports.PrevisionApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options = {}) {
            // verify required parameter 'PrevisionApplyGroupDto' is not null or undefined
            if (PrevisionApplyGroupDto === null || PrevisionApplyGroupDto === undefined) {
                throw new RequiredError('PrevisionApplyGroupDto', 'Required parameter PrevisionApplyGroupDto was null or undefined when calling v1PrevisionGroupApplyPrevisionPost.');
            }
            const localVarPath = `/v1/prevision/group-apply-prevision`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PrevisionApplyGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(PrevisionApplyGroupDto || {}) : (PrevisionApplyGroupDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch data previsions for a given year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1PrevisionListSourceIdYearGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1PrevisionListSourceIdYearGet.');
            }
            const localVarPath = `/v1/prevision/list/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Generate default previsions for the source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options = {}) {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year', 'Required parameter year was null or undefined when calling v1PrevisionSaveDefaultPrevisionsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1PrevisionSaveDefaultPrevisionsSourceIdYearPost.');
            }
            const localVarPath = `/v1/prevision/save-default-previsions/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto, options = {}) {
            // verify required parameter 'PrevisionBulkSaveDto' is not null or undefined
            if (PrevisionBulkSaveDto === null || PrevisionBulkSaveDto === undefined) {
                throw new RequiredError('PrevisionBulkSaveDto', 'Required parameter PrevisionBulkSaveDto was null or undefined when calling v1PrevisionSavePost.');
            }
            const localVarPath = `/v1/prevision/save`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PrevisionBulkSaveDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(PrevisionBulkSaveDto || {}) : (PrevisionBulkSaveDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto, options = {}) {
            // verify required parameter 'PrevisionPatchDto' is not null or undefined
            if (PrevisionPatchDto === null || PrevisionPatchDto === undefined) {
                throw new RequiredError('PrevisionPatchDto', 'Required parameter PrevisionPatchDto was null or undefined when calling v1PrevisionUpdatePatch.');
            }
            const localVarPath = `/v1/prevision/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PrevisionPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(PrevisionPatchDto || {}) : (PrevisionPatchDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PrevisionApi - functional programming interface
 * @export
 */
exports.PrevisionApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options) {
            const localVarFetchArgs = exports.PrevisionApiFetchParamCreator(configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Fetch data previsions for a given year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year, sourceId, options) {
            const localVarFetchArgs = exports.PrevisionApiFetchParamCreator(configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Generate default previsions for the source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options) {
            const localVarFetchArgs = exports.PrevisionApiFetchParamCreator(configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto, options) {
            const localVarFetchArgs = exports.PrevisionApiFetchParamCreator(configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto, options) {
            const localVarFetchArgs = exports.PrevisionApiFetchParamCreator(configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * PrevisionApi - factory interface
 * @export
 */
exports.PrevisionApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options) {
            return exports.PrevisionApiFp(configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetch data previsions for a given year
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year, sourceId, options) {
            return exports.PrevisionApiFp(configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Generate default previsions for the source and save them
         * @param {number} year
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options) {
            return exports.PrevisionApiFp(configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto, options) {
            return exports.PrevisionApiFp(configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto, options) {
            return exports.PrevisionApiFp(configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options)(fetch, basePath);
        },
    };
};
/**
 * PrevisionApi - object-oriented interface
 * @export
 * @class PrevisionApi
 * @extends {BaseAPI}
 */
class PrevisionApi extends BaseAPI {
    /**
     *
     * @summary Apply a source prevision to the whole group
     * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options) {
        return exports.PrevisionApiFp(this.configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetch data previsions for a given year
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    v1PrevisionListSourceIdYearGet(year, sourceId, options) {
        return exports.PrevisionApiFp(this.configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Generate default previsions for the source and save them
     * @param {number} year
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options) {
        return exports.PrevisionApiFp(this.configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Save many previsions at once
     * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    v1PrevisionSavePost(PrevisionBulkSaveDto, options) {
        return exports.PrevisionApiFp(this.configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a specific prevision
     * @param {PrevisionPatchDto} PrevisionPatchDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    v1PrevisionUpdatePatch(PrevisionPatchDto, options) {
        return exports.PrevisionApiFp(this.configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options)(this.fetch, this.basePath);
    }
}
exports.PrevisionApi = PrevisionApi;
/**
 * SourceApi - fetch parameter creator
 * @export
 */
exports.SourceApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options = {}) {
            const localVarPath = `/v1/source/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a source and all linked data
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId, options = {}) {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1SourceSourceIdDelete.');
            }
            const localVarPath = `/v1/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options = {}) {
            // verify required parameter 'SourcePatchGroupDto' is not null or undefined
            if (SourcePatchGroupDto === null || SourcePatchGroupDto === undefined) {
                throw new RequiredError('SourcePatchGroupDto', 'Required parameter SourcePatchGroupDto was null or undefined when calling v1SourceSourceIdGroupPatch.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1SourceSourceIdGroupPatch.');
            }
            const localVarPath = `/v1/source/{sourceId}/group`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SourcePatchGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(SourcePatchGroupDto || {}) : (SourcePatchGroupDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto, sourceId, options = {}) {
            // verify required parameter 'SourcePatchDto' is not null or undefined
            if (SourcePatchDto === null || SourcePatchDto === undefined) {
                throw new RequiredError('SourcePatchDto', 'Required parameter SourcePatchDto was null or undefined when calling v1SourceSourceIdPatch.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1SourceSourceIdPatch.');
            }
            const localVarPath = `/v1/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SourcePatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(SourcePatchDto || {}) : (SourcePatchDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SourceApi - functional programming interface
 * @export
 */
exports.SourceApiFp = function (configuration) {
    return {
        /**
         *
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options) {
            const localVarFetchArgs = exports.SourceApiFetchParamCreator(configuration).v1SourceListGet(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete a source and all linked data
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId, options) {
            const localVarFetchArgs = exports.SourceApiFetchParamCreator(configuration).v1SourceSourceIdDelete(sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options) {
            const localVarFetchArgs = exports.SourceApiFetchParamCreator(configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto, sourceId, options) {
            const localVarFetchArgs = exports.SourceApiFetchParamCreator(configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SourceApi - factory interface
 * @export
 */
exports.SourceApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options) {
            return exports.SourceApiFp(configuration).v1SourceListGet(options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a source and all linked data
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId, options) {
            return exports.SourceApiFp(configuration).v1SourceSourceIdDelete(sourceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options) {
            return exports.SourceApiFp(configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto, sourceId, options) {
            return exports.SourceApiFp(configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options)(fetch, basePath);
        },
    };
};
/**
 * SourceApi - object-oriented interface
 * @export
 * @class SourceApi
 * @extends {BaseAPI}
 */
class SourceApi extends BaseAPI {
    /**
     *
     * @summary All user sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    v1SourceListGet(options) {
        return exports.SourceApiFp(this.configuration).v1SourceListGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a source and all linked data
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    v1SourceSourceIdDelete(sourceId, options) {
        return exports.SourceApiFp(this.configuration).v1SourceSourceIdDelete(sourceId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a source group
     * @param {SourcePatchGroupDto} SourcePatchGroupDto
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options) {
        return exports.SourceApiFp(this.configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a source
     * @param {SourcePatchDto} SourcePatchDto
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    v1SourceSourceIdPatch(SourcePatchDto, sourceId, options) {
        return exports.SourceApiFp(this.configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options)(this.fetch, this.basePath);
    }
}
exports.SourceApi = SourceApi;
/**
 * SourceGroupApi - fetch parameter creator
 * @export
 */
exports.SourceGroupApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto, options = {}) {
            // verify required parameter 'SourceGroupCreateDto' is not null or undefined
            if (SourceGroupCreateDto === null || SourceGroupCreateDto === undefined) {
                throw new RequiredError('SourceGroupCreateDto', 'Required parameter SourceGroupCreateDto was null or undefined when calling v1SourceGroupCreatePost.');
            }
            const localVarPath = `/v1/source-group/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SourceGroupCreateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(SourceGroupCreateDto || {}) : (SourceGroupCreateDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options = {}) {
            // verify required parameter 'SourceGroupPatchDto' is not null or undefined
            if (SourceGroupPatchDto === null || SourceGroupPatchDto === undefined) {
                throw new RequiredError('SourceGroupPatchDto', 'Required parameter SourceGroupPatchDto was null or undefined when calling v1SourceGroupGroupIdPatch.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling v1SourceGroupGroupIdPatch.');
            }
            const localVarPath = `/v1/source-group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SourceGroupPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(SourceGroupPatchDto || {}) : (SourceGroupPatchDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options = {}) {
            const localVarPath = `/v1/source-group/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SourceGroupApi - functional programming interface
 * @export
 */
exports.SourceGroupApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto, options) {
            const localVarFetchArgs = exports.SourceGroupApiFetchParamCreator(configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options) {
            const localVarFetchArgs = exports.SourceGroupApiFetchParamCreator(configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options) {
            const localVarFetchArgs = exports.SourceGroupApiFetchParamCreator(configuration).v1SourceGroupListGet(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SourceGroupApi - factory interface
 * @export
 */
exports.SourceGroupApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto, options) {
            return exports.SourceGroupApiFp(configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options)(fetch, basePath);
        },
        /**
         *
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto
         * @param {number} groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options) {
            return exports.SourceGroupApiFp(configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options) {
            return exports.SourceGroupApiFp(configuration).v1SourceGroupListGet(options)(fetch, basePath);
        },
    };
};
/**
 * SourceGroupApi - object-oriented interface
 * @export
 * @class SourceGroupApi
 * @extends {BaseAPI}
 */
class SourceGroupApi extends BaseAPI {
    /**
     *
     * @summary Create a new source groups
     * @param {SourceGroupCreateDto} SourceGroupCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    v1SourceGroupCreatePost(SourceGroupCreateDto, options) {
        return exports.SourceGroupApiFp(this.configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Updates a group configuration
     * @param {SourceGroupPatchDto} SourceGroupPatchDto
     * @param {number} groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options) {
        return exports.SourceGroupApiFp(this.configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary All source groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    v1SourceGroupListGet(options) {
        return exports.SourceGroupApiFp(this.configuration).v1SourceGroupListGet(options)(this.fetch, this.basePath);
    }
}
exports.SourceGroupApi = SourceGroupApi;
/**
 * UserApi - fetch parameter creator
 * @export
 */
exports.UserApiFetchParamCreator = function (configuration) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto, options = {}) {
            // verify required parameter 'LoginDto' is not null or undefined
            if (LoginDto === null || LoginDto === undefined) {
                throw new RequiredError('LoginDto', 'Required parameter LoginDto was null or undefined when calling v1UserLoginPost.');
            }
            const localVarPath = `/v1/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("LoginDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(LoginDto || {}) : (LoginDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options = {}) {
            const localVarPath = `/v1/user/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {RequestDemoDto} RequestDemoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto, options = {}) {
            // verify required parameter 'RequestDemoDto' is not null or undefined
            if (RequestDemoDto === null || RequestDemoDto === undefined) {
                throw new RequiredError('RequestDemoDto', 'Required parameter RequestDemoDto was null or undefined when calling v1UserRegisterDemoPost.');
            }
            const localVarPath = `/v1/user/register-demo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RequestDemoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(RequestDemoDto || {}) : (RequestDemoDto || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).v1UserLoginPost(LoginDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).v1UserMeGet(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {RequestDemoDto} RequestDemoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).v1UserRegisterDemoPost(RequestDemoDto, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto, options) {
            return exports.UserApiFp(configuration).v1UserLoginPost(LoginDto, options)(fetch, basePath);
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options) {
            return exports.UserApiFp(configuration).v1UserMeGet(options)(fetch, basePath);
        },
        /**
         *
         * @param {RequestDemoDto} RequestDemoDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto, options) {
            return exports.UserApiFp(configuration).v1UserRegisterDemoPost(RequestDemoDto, options)(fetch, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
     * @summary Log the user in
     * @param {LoginDto} LoginDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    v1UserLoginPost(LoginDto, options) {
        return exports.UserApiFp(this.configuration).v1UserLoginPost(LoginDto, options)(this.fetch, this.basePath);
    }
    /**
     * Must be authenticated to call this endpoint
     * @summary Retrieve current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    v1UserMeGet(options) {
        return exports.UserApiFp(this.configuration).v1UserMeGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param {RequestDemoDto} RequestDemoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    v1UserRegisterDemoPost(RequestDemoDto, options) {
        return exports.UserApiFp(this.configuration).v1UserRegisterDemoPost(RequestDemoDto, options)(this.fetch, this.basePath);
    }
}
exports.UserApi = UserApi;
/**
 * ViewHelperApi - fetch parameter creator
 * @export
 */
exports.ViewHelperApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options = {}) {
            const localVarPath = `/v1/view-helper/alerts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options = {}) {
            const localVarPath = `/v1/view-helper/alerts-ref`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the alert modal view data
         * @param {string} dayDate
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options = {}) {
            // verify required parameter 'dayDate' is not null or undefined
            if (dayDate === null || dayDate === undefined) {
                throw new RequiredError('dayDate', 'Required parameter dayDate was null or undefined when calling v1ViewHelperDaysNearDateSourceIdDayDateGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId', 'Required parameter sourceId was null or undefined when calling v1ViewHelperDaysNearDateSourceIdDayDateGet.');
            }
            const localVarPath = `/v1/view-helper/days-near-date/{sourceId}/{dayDate}`
                .replace(`{${"dayDate"}}`, encodeURIComponent(String(dayDate)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ViewHelperApi - functional programming interface
 * @export
 */
exports.ViewHelperApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options) {
            const localVarFetchArgs = exports.ViewHelperApiFetchParamCreator(configuration).v1ViewHelperAlertsGet(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options) {
            const localVarFetchArgs = exports.ViewHelperApiFetchParamCreator(configuration).v1ViewHelperAlertsRefGet(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get the alert modal view data
         * @param {string} dayDate
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options) {
            const localVarFetchArgs = exports.ViewHelperApiFetchParamCreator(configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ViewHelperApi - factory interface
 * @export
 */
exports.ViewHelperApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options) {
            return exports.ViewHelperApiFp(configuration).v1ViewHelperAlertsGet(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options) {
            return exports.ViewHelperApiFp(configuration).v1ViewHelperAlertsRefGet(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get the alert modal view data
         * @param {string} dayDate
         * @param {number} sourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options) {
            return exports.ViewHelperApiFp(configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options)(fetch, basePath);
        },
    };
};
/**
 * ViewHelperApi - object-oriented interface
 * @export
 * @class ViewHelperApi
 * @extends {BaseAPI}
 */
class ViewHelperApi extends BaseAPI {
    /**
     *
     * @summary Get the alert view data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    v1ViewHelperAlertsGet(options) {
        return exports.ViewHelperApiFp(this.configuration).v1ViewHelperAlertsGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get the alert referential view data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    v1ViewHelperAlertsRefGet(options) {
        return exports.ViewHelperApiFp(this.configuration).v1ViewHelperAlertsRefGet(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get the alert modal view data
     * @param {string} dayDate
     * @param {number} sourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options) {
        return exports.ViewHelperApiFp(this.configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options)(this.fetch, this.basePath);
    }
}
exports.ViewHelperApi = ViewHelperApi;
