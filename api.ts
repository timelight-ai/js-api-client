/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * timelight
 * This is the timelight api.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AlertCommentDto
 */
export interface AlertCommentDto {
    /**
     * The text comment to set on the alert, max of 5000 characters
     * @type {string}
     * @memberof AlertCommentDto
     */
    comment: string;
}

/**
 * 
 * @export
 * @interface AlertDto
 */
export interface AlertDto {
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    source_id: number;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    criticity: number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertDto
     */
    shape: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertDto
     */
    activity: AlertDto.ActivityEnum;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    better_model_id: number;
    /**
     * 
     * @type {number}
     * @memberof AlertDto
     */
    closest_model_id: number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertDto
     */
    favorite: boolean;
}

/**
 * @export
 * @namespace AlertDto
 */
export namespace AlertDto {
    /**
     * @export
     * @enum {string}
     */
    export enum ActivityEnum {
        Over = <any> 'over',
        Under = <any> 'under'
    }
}

/**
 * 
 * @export
 * @interface AlertFavoriteDto
 */
export interface AlertFavoriteDto {
    /**
     * True to be set as favorite, false otherwise
     * @type {boolean}
     * @memberof AlertFavoriteDto
     */
    favorite: boolean;
}

/**
 * 
 * @export
 * @interface AlertListDto
 */
export interface AlertListDto {
    /**
     * List of alerts
     * @type {Array<AlertDto>}
     * @memberof AlertListDto
     */
    alerts: Array<AlertDto>;
}

/**
 * 
 * @export
 * @interface AlertRefDto
 */
export interface AlertRefDto {
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    source_id: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    criticity: number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRefDto
     */
    shape: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    activity: AlertRefDto.ActivityEnum;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    comment: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayActivity: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    betterModelName: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    betterModelValue: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    betterModelColor: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    betterModelActivity: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    betterModelTopTolerance: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    betterModelBottomTolerance: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    closestModelName: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    closestModelValue: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    closestModelColor: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    closestModelActivity: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    closestModelTopTolerance: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    closestModelBottomTolerance: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    dayModelName: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    dayModelValue: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    dayModelColor: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayModelActivity: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayModelTopTolerance: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayModelBottomTolerance: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    dayPrevisionModelName: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRefDto
     */
    dayPrevisionModelValue: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRefDto
     */
    dayPrevisionModelColor: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayPrevisionModelActivity: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayPrevisionModelTopTolerance: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AlertRefDto
     */
    dayPrevisionModelBottomTolerance: Array<number>;
}

/**
 * @export
 * @namespace AlertRefDto
 */
export namespace AlertRefDto {
    /**
     * @export
     * @enum {string}
     */
    export enum ActivityEnum {
        Over = <any> 'over',
        Under = <any> 'under'
    }
}

/**
 * 
 * @export
 * @interface AlertRefListDto
 */
export interface AlertRefListDto {
    /**
     * List of alerts refs
     * @type {Array<AlertRefDto>}
     * @memberof AlertRefListDto
     */
    alertRefs: Array<AlertRefDto>;
}

/**
 * 
 * @export
 * @interface AlertRefResultDto
 */
export interface AlertRefResultDto {
    /**
     * List of alert ref
     * @type {Array<AlertRefDto>}
     * @memberof AlertRefResultDto
     */
    alerts: Array<AlertRefDto>;
    /**
     * List of sources
     * @type {Array<SourceDto>}
     * @memberof AlertRefResultDto
     */
    sources: Array<SourceDto>;
}

/**
 * 
 * @export
 * @interface AnomaliesResponseDto
 */
export interface AnomaliesResponseDto {
    /**
     * Dates with anomalies
     * @type {Array<string>}
     * @memberof AnomaliesResponseDto
     */
    dates: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateSourceDayDto
 */
export interface CreateSourceDayDto {
    /**
     * The date with a format YYYY-MM-DD
     * @type {string}
     * @memberof CreateSourceDayDto
     */
    date: string;
    /**
     * An array of 144 values. Each value represents a time window of 10 minutes
     * @type {Array<number>}
     * @memberof CreateSourceDayDto
     */
    activity: Array<number>;
}

/**
 * 
 * @export
 * @interface CreateSourceDto
 */
export interface CreateSourceDto {
    /**
     * The source name, between 2 and 100 characters
     * @type {string}
     * @memberof CreateSourceDto
     */
    name: string;
    /**
     * The source reference year, used to train our models
     * @type {number}
     * @memberof CreateSourceDto
     */
    referenceYear: number;
    /**
     * The source latitude
     * @type {number}
     * @memberof CreateSourceDto
     */
    latitude: number;
    /**
     * The source longitude
     * @type {number}
     * @memberof CreateSourceDto
     */
    longitude: number;
    /**
     * The source physical address
     * @type {string}
     * @memberof CreateSourceDto
     */
    address: string;
    /**
     * List of day data
     * @type {Array<CreateSourceDayDto>}
     * @memberof CreateSourceDto
     */
    days: Array<CreateSourceDayDto>;
}

/**
 * 
 * @export
 * @interface DayContext
 */
export interface DayContext {
    /**
     * 
     * @type {number}
     * @memberof DayContext
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof DayContext
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayContext
     */
    updatedDate: string;
    /**
     * The context date in format \"yyyy-mm-dd\"
     * @type {string}
     * @memberof DayContext
     */
    dayDate: string;
    /**
     * 
     * @type {number}
     * @memberof DayContext
     */
    sourceId: number;
    /**
     * Context type
     * @type {string}
     * @memberof DayContext
     */
    ctxType: DayContext.CtxTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof DayContext
     */
    activity: any;
    /**
     * 
     * @type {any}
     * @memberof DayContext
     */
    value: any;
}

/**
 * @export
 * @namespace DayContext
 */
export namespace DayContext {
    /**
     * @export
     * @enum {string}
     */
    export enum CtxTypeEnum {
        Dju = <any> 'dju',
        TempMaxDeg = <any> 'temp_max_deg',
        TempMinDeg = <any> 'temp_min_deg',
        WindSpeedKmh = <any> 'wind_speed_kmh',
        WindTempDeg = <any> 'wind_temp_deg',
        RainMm = <any> 'rain_mm',
        HumidityPerc = <any> 'humidity_perc',
        VisibilityKm = <any> 'visibility_km',
        CloudCoverPerc = <any> 'cloud_cover_perc',
        HeatIdxUnit = <any> 'heat_idx_unit',
        DewPointDeg = <any> 'dew_point_deg',
        PressureHpa = <any> 'pressure_hpa',
        SunriseSec = <any> 'sunrise_sec',
        SunsetSec = <any> 'sunset_sec',
        DayLengthSec = <any> 'day_length_sec',
        HistoriqueMeteoEnum = <any> 'historique_meteo_enum'
    }
}

/**
 * 
 * @export
 * @interface DayListDto
 */
export interface DayListDto {
    /**
     * List of days with a matching model
     * @type {Array<DayModelDto>}
     * @memberof DayListDto
     */
    days: Array<DayModelDto>;
}

/**
 * 
 * @export
 * @interface DayModelDto
 */
export interface DayModelDto {
    /**
     * 
     * @type {string}
     * @memberof DayModelDto
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof DayModelDto
     */
    value: number;
    /**
     * 
     * @type {number}
     * @memberof DayModelDto
     */
    inertia: number;
    /**
     * 
     * @type {number}
     * @memberof DayModelDto
     */
    model_id: number;
    /**
     * 
     * @type {boolean}
     * @memberof DayModelDto
     */
    anomaly: boolean;
    /**
     * 
     * @type {number}
     * @memberof DayModelDto
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof DayModelDto
     */
    y: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DayModelDto
     */
    activity: Array<number>;
}

/**
 * 
 * @export
 * @interface DayPatchDto
 */
export interface DayPatchDto {
    /**
     * The date with a format YYYY-MM-DD
     * @type {string}
     * @memberof DayPatchDto
     */
    date: string;
    /**
     * True if the day is an anomaly and should be ignored by the ML engine
     * @type {boolean}
     * @memberof DayPatchDto
     */
    anomaly: boolean;
}

/**
 * 
 * @export
 * @interface DayTrend
 */
export interface DayTrend {
    /**
     * 
     * @type {number}
     * @memberof DayTrend
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    updatedDate: string;
    /**
     * 
     * @type {number}
     * @memberof DayTrend
     */
    sourceId: number;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    startDayDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    stopDayDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    unit: DayTrend.UnitEnum;
    /**
     * 
     * @type {string}
     * @memberof DayTrend
     */
    type: DayTrend.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DayTrend
     */
    value: number;
}

/**
 * @export
 * @namespace DayTrend
 */
export namespace DayTrend {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        Percent = <any> 'percent',
        Unit = <any> 'unit'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        OneShot = <any> 'one-shot',
        Weekly = <any> 'weekly',
        Monthly = <any> 'monthly'
    }
}

/**
 * 
 * @export
 * @interface DayTrendInput
 */
export interface DayTrendInput {
    /**
     * 
     * @type {string}
     * @memberof DayTrendInput
     */
    startDayDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayTrendInput
     */
    stopDayDate: string;
    /**
     * 
     * @type {string}
     * @memberof DayTrendInput
     */
    unit: DayTrendInput.UnitEnum;
    /**
     * 
     * @type {string}
     * @memberof DayTrendInput
     */
    type: DayTrendInput.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DayTrendInput
     */
    value: number;
}

/**
 * @export
 * @namespace DayTrendInput
 */
export namespace DayTrendInput {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        Percent = <any> 'percent',
        Unit = <any> 'unit'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        OneShot = <any> 'one-shot',
        Weekly = <any> 'weekly',
        Monthly = <any> 'monthly'
    }
}

/**
 * 
 * @export
 * @interface DayTrendInputListDto
 */
export interface DayTrendInputListDto {
    /**
     * List of day trends
     * @type {Array<DayTrendInput>}
     * @memberof DayTrendInputListDto
     */
    dayTrends: Array<DayTrendInput>;
}

/**
 * 
 * @export
 * @interface DayTrendListDto
 */
export interface DayTrendListDto {
    /**
     * List of day trends
     * @type {Array<DayTrend>}
     * @memberof DayTrendListDto
     */
    dayTrends: Array<DayTrend>;
}

/**
 * 
 * @export
 * @interface DaysNearDateResultDto
 */
export interface DaysNearDateResultDto {
    /**
     * List of models
     * @type {Array<ModelDto>}
     * @memberof DaysNearDateResultDto
     */
    models: Array<ModelDto>;
    /**
     * List of days around the target date
     * @type {Array<DayModelDto>}
     * @memberof DaysNearDateResultDto
     */
    days: Array<DayModelDto>;
    /**
     * List of days near the target date in distance
     * @type {Array<DayModelDto>}
     * @memberof DaysNearDateResultDto
     */
    nearestDistanceDays: Array<DayModelDto>;
    /**
     * 
     * @type {DayModelDto}
     * @memberof DaysNearDateResultDto
     */
    day: DayModelDto;
    /**
     * 
     * @type {SourceDto}
     * @memberof DaysNearDateResultDto
     */
    source: SourceDto;
    /**
     * List of previsions
     * @type {Array<PrevisionDto>}
     * @memberof DaysNearDateResultDto
     */
    previsions: Array<PrevisionDto>;
    /**
     * List of alerts
     * @type {Array<AlertDto>}
     * @memberof DaysNearDateResultDto
     */
    alerts: Array<AlertDto>;
    /**
     * List of alerts refs
     * @type {Array<AlertRefDto>}
     * @memberof DaysNearDateResultDto
     */
    alertRefs: Array<AlertRefDto>;
}

/**
 * 
 * @export
 * @interface DaysPatchDto
 */
export interface DaysPatchDto {
    /**
     * The source id to update days on
     * @type {number}
     * @memberof DaysPatchDto
     */
    sourceId: number;
    /**
     * The list of days to update
     * @type {Array<DayPatchDto>}
     * @memberof DaysPatchDto
     */
    days: Array<DayPatchDto>;
}

/**
 * 
 * @export
 * @interface GeneratedDayContextBulkDto
 */
export interface GeneratedDayContextBulkDto {
    /**
     * 
     * @type {Array<DayContext>}
     * @memberof GeneratedDayContextBulkDto
     */
    bulk: Array<DayContext>;
}

/**
 * 
 * @export
 * @interface GeneratedDayTrendBulkDto
 */
export interface GeneratedDayTrendBulkDto {
    /**
     * 
     * @type {Array<DayTrend>}
     * @memberof GeneratedDayTrendBulkDto
     */
    bulk: Array<DayTrend>;
}

/**
 * 
 * @export
 * @interface ImportDayDto
 */
export interface ImportDayDto {
    /**
     * The date with a format YYYY-MM-DD
     * @type {string}
     * @memberof ImportDayDto
     */
    date: string;
    /**
     * An array of 144 values. Each value represents a time window of 10 minutes
     * @type {Array<number>}
     * @memberof ImportDayDto
     */
    activity: Array<number>;
}

/**
 * 
 * @export
 * @interface ImportDaysDto
 */
export interface ImportDaysDto {
    /**
     * The source id to add data to
     * @type {number}
     * @memberof ImportDaysDto
     */
    sourceId: number;
    /**
     * The list of days to add
     * @type {Array<ImportDayDto>}
     * @memberof ImportDaysDto
     */
    days: Array<ImportDayDto>;
}

/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * The user name
     * @type {string}
     * @memberof LoginDto
     */
    username: string;
    /**
     * Our super secret password
     * @type {string}
     * @memberof LoginDto
     */
    password: string;
}

/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * Our super secret json web token
     * @type {string}
     * @memberof LoginResponseDto
     */
    jwt: string;
}

/**
 * 
 * @export
 * @interface ModelDto
 */
export interface ModelDto {
    /**
     * 
     * @type {number}
     * @memberof ModelDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ModelDto
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof ModelDto
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelDto
     */
    activity: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelDto
     */
    top_tolerance: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ModelDto
     */
    bottom_tolerance: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ModelDto
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof ModelDto
     */
    y: number;
    /**
     * 
     * @type {number}
     * @memberof ModelDto
     */
    value: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelDto
     */
    anomaly: boolean;
}

/**
 * 
 * @export
 * @interface ModelListDto
 */
export interface ModelListDto {
    /**
     * List of models
     * @type {Array<ModelDto>}
     * @memberof ModelListDto
     */
    models: Array<ModelDto>;
}

/**
 * 
 * @export
 * @interface ModelPatchDto
 */
export interface ModelPatchDto {
    /**
     * The model id
     * @type {number}
     * @memberof ModelPatchDto
     */
    id: number;
    /**
     * The color in hex format. Ex: '#FFFFFF'
     * @type {string}
     * @memberof ModelPatchDto
     */
    color: string;
    /**
     * The model name, between 1 and 100 characters
     * @type {string}
     * @memberof ModelPatchDto
     */
    name: string;
    /**
     * True if the model is an anomaly and should be ignored by the ML engine
     * @type {boolean}
     * @memberof ModelPatchDto
     */
    anomaly: boolean;
}

/**
 * 
 * @export
 * @interface ModelsPatchDto
 */
export interface ModelsPatchDto {
    /**
     * The list of models to be updated
     * @type {Array<ModelPatchDto>}
     * @memberof ModelsPatchDto
     */
    models: Array<ModelPatchDto>;
}

/**
 * 
 * @export
 * @interface PrevisionApplyGroupDto
 */
export interface PrevisionApplyGroupDto {
    /**
     * The source id apply prevision from
     * @type {number}
     * @memberof PrevisionApplyGroupDto
     */
    sourceId: number;
}

/**
 * 
 * @export
 * @interface PrevisionApplyGroupResponseDto
 */
export interface PrevisionApplyGroupResponseDto {
}

/**
 * 
 * @export
 * @interface PrevisionBulkSaveDto
 */
export interface PrevisionBulkSaveDto {
    /**
     * The year to update the prevision, must be in the future
     * @type {number}
     * @memberof PrevisionBulkSaveDto
     */
    year: number;
    /**
     * The source id to update previsions on
     * @type {number}
     * @memberof PrevisionBulkSaveDto
     */
    sourceId: number;
    /**
     * List of previsions to update
     * @type {Array<PrevisionSaveDto>}
     * @memberof PrevisionBulkSaveDto
     */
    previsions: Array<PrevisionSaveDto>;
}

/**
 * 
 * @export
 * @interface PrevisionBulkSaveResultDto
 */
export interface PrevisionBulkSaveResultDto {
    /**
     * The updated prevision objects
     * @type {Array<PrevisionDto>}
     * @memberof PrevisionBulkSaveResultDto
     */
    previsions: Array<PrevisionDto>;
    /**
     * List of newly created alerts
     * @type {Array<AlertDto>}
     * @memberof PrevisionBulkSaveResultDto
     */
    alerts: Array<AlertDto>;
}

/**
 * 
 * @export
 * @interface PrevisionDto
 */
export interface PrevisionDto {
    /**
     * 
     * @type {string}
     * @memberof PrevisionDto
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof PrevisionDto
     */
    model_id: number;
}

/**
 * 
 * @export
 * @interface PrevisionListDto
 */
export interface PrevisionListDto {
    /**
     * List of previsions
     * @type {Array<PrevisionDto>}
     * @memberof PrevisionListDto
     */
    previsions: Array<PrevisionDto>;
    /**
     * If true, those previsions are user saved previsions and can be updated.If false, you can not update previsions, you have to save them first
     * @type {boolean}
     * @memberof PrevisionListDto
     */
    hasSavedPrevisions: boolean;
}

/**
 * 
 * @export
 * @interface PrevisionPatchDto
 */
export interface PrevisionPatchDto {
    /**
     * The source id of the prevision to update
     * @type {number}
     * @memberof PrevisionPatchDto
     */
    sourceId: number;
    /**
     * The prevision date with a format YYYY-MM-DD
     * @type {string}
     * @memberof PrevisionPatchDto
     */
    date: string;
    /**
     * New model id to set on the prevision
     * @type {number}
     * @memberof PrevisionPatchDto
     */
    modelId: number;
}

/**
 * 
 * @export
 * @interface PrevisionSaveDto
 */
export interface PrevisionSaveDto {
    /**
     * The date with a format YYYY-MM-DD, part of the prevision PK
     * @type {string}
     * @memberof PrevisionSaveDto
     */
    date: string;
    /**
     * Model id of the prevision, part of the prevision PK
     * @type {number}
     * @memberof PrevisionSaveDto
     */
    modelId: number;
}

/**
 * 
 * @export
 * @interface PrevisionUpdateResultDto
 */
export interface PrevisionUpdateResultDto {
    /**
     * 
     * @type {PrevisionDto}
     * @memberof PrevisionUpdateResultDto
     */
    prevision: PrevisionDto;
    /**
     * List of newly created alerts
     * @type {Array<AlertDto>}
     * @memberof PrevisionUpdateResultDto
     */
    alerts: Array<AlertDto>;
}

/**
 * 
 * @export
 * @interface RecomputeDayModelsResponseDto
 */
export interface RecomputeDayModelsResponseDto {
    /**
     * The updated day models
     * @type {Array<DayModelDto>}
     * @memberof RecomputeDayModelsResponseDto
     */
    days: Array<DayModelDto>;
}

/**
 * 
 * @export
 * @interface RecomputeDaysProjectionResponseDto
 */
export interface RecomputeDaysProjectionResponseDto {
    /**
     * The updated day models
     * @type {Array<DayModelDto>}
     * @memberof RecomputeDaysProjectionResponseDto
     */
    days: Array<DayModelDto>;
}

/**
 * 
 * @export
 * @interface RecomputeModelsResponseDto
 */
export interface RecomputeModelsResponseDto {
    /**
     * Our newly created models
     * @type {Array<ModelDto>}
     * @memberof RecomputeModelsResponseDto
     */
    models: Array<ModelDto>;
    /**
     * List of days with a matching model
     * @type {Array<DayModelDto>}
     * @memberof RecomputeModelsResponseDto
     */
    days: Array<DayModelDto>;
}

/**
 * 
 * @export
 * @interface RecomputeSourceModelsResponseDto
 */
export interface RecomputeSourceModelsResponseDto {
    /**
     * The updated sources
     * @type {Array<SourceDto>}
     * @memberof RecomputeSourceModelsResponseDto
     */
    sources: Array<SourceDto>;
    /**
     * The new source groups
     * @type {Array<SourceGroupDto>}
     * @memberof RecomputeSourceModelsResponseDto
     */
    groups: Array<SourceGroupDto>;
}

/**
 * 
 * @export
 * @interface RequestDemoDto
 */
export interface RequestDemoDto {
    /**
     * User email
     * @type {string}
     * @memberof RequestDemoDto
     */
    email: string;
    /**
     * User name
     * @type {string}
     * @memberof RequestDemoDto
     */
    name: string;
    /**
     * Company name
     * @type {string}
     * @memberof RequestDemoDto
     */
    company: string;
    /**
     * Company position
     * @type {string}
     * @memberof RequestDemoDto
     */
    position: string;
}

/**
 * 
 * @export
 * @interface SourceDto
 */
export interface SourceDto {
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SourceDto
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    groupId: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    groupInertia: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    projectionX: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    projectionY: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    referenceYear: number;
    /**
     * 
     * @type {boolean}
     * @memberof SourceDto
     */
    hasPrevision: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SourceDto
     */
    previsionEnabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    latitude: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    longitude: number;
    /**
     * 
     * @type {string}
     * @memberof SourceDto
     */
    address: string;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    alertMinCriticity: number;
    /**
     * 
     * @type {number}
     * @memberof SourceDto
     */
    alertMaxCriticity: number;
}

/**
 * 
 * @export
 * @interface SourceGroupCreateDto
 */
export interface SourceGroupCreateDto {
    /**
     * The new group name
     * @type {string}
     * @memberof SourceGroupCreateDto
     */
    name: string;
}

/**
 * 
 * @export
 * @interface SourceGroupDto
 */
export interface SourceGroupDto {
    /**
     * 
     * @type {number}
     * @memberof SourceGroupDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SourceGroupDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SourceGroupDto
     */
    color: string;
}

/**
 * 
 * @export
 * @interface SourceGroupListDto
 */
export interface SourceGroupListDto {
    /**
     * 
     * @type {Array<SourceGroupDto>}
     * @memberof SourceGroupListDto
     */
    groups: Array<SourceGroupDto>;
}

/**
 * 
 * @export
 * @interface SourceGroupPatchDto
 */
export interface SourceGroupPatchDto {
    /**
     * The group name
     * @type {string}
     * @memberof SourceGroupPatchDto
     */
    name: string;
    /**
     * The group color
     * @type {string}
     * @memberof SourceGroupPatchDto
     */
    color: string;
}

/**
 * 
 * @export
 * @interface SourceListDto
 */
export interface SourceListDto {
    /**
     * 
     * @type {Array<SourceDto>}
     * @memberof SourceListDto
     */
    sources: Array<SourceDto>;
}

/**
 * 
 * @export
 * @interface SourcePatchDto
 */
export interface SourcePatchDto {
    /**
     * The source name
     * @type {string}
     * @memberof SourcePatchDto
     */
    name: string;
    /**
     * The source ability to generate alerts from previsions
     * @type {boolean}
     * @memberof SourcePatchDto
     */
    previsionEnabled: boolean;
    /**
     * The source latitude
     * @type {number}
     * @memberof SourcePatchDto
     */
    latitude: number;
    /**
     * The source longitude
     * @type {number}
     * @memberof SourcePatchDto
     */
    longitude: number;
    /**
     * The source physical address
     * @type {string}
     * @memberof SourcePatchDto
     */
    address: string;
    /**
     * The source minimum criticity to trigger an alert
     * @type {number}
     * @memberof SourcePatchDto
     */
    alertMinCriticity: number;
    /**
     * The source maximum criticity to trigger an alert
     * @type {number}
     * @memberof SourcePatchDto
     */
    alertMaxCriticity: number;
}

/**
 * 
 * @export
 * @interface SourcePatchGroupDto
 */
export interface SourcePatchGroupDto {
    /**
     * The new group id
     * @type {number}
     * @memberof SourcePatchGroupDto
     */
    groupId: number;
}

/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    email: string;
    /**
     * User unique login
     * @type {string}
     * @memberof UserDto
     */
    username: string;
}


/**
 * AIApi - fetch parameter creator
 * @export
 */
export const AIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auto detect-anomalies
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1AiAnomaliesSourceIdGet.');
            }
            const localVarPath = `/v1/ai/anomalies/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1AiRecomputeDayModelsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1AiRecomputeDayModelsSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-day-models/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1AiRecomputeDaysProjectionSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1AiRecomputeDaysProjectionSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-days-projection/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year 
         * @param {number} sourceId 
         * @param {number} [modelCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year: number, sourceId: number, modelCount?: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1AiRecomputeModelsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1AiRecomputeModelsSourceIdYearPost.');
            }
            const localVarPath = `/v1/ai/recompute-models/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (modelCount !== undefined) {
                localVarQueryParameter['modelCount'] = modelCount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount: number, options: any = {}): FetchArgs {
            // verify required parameter 'modelCount' is not null or undefined
            if (modelCount === null || modelCount === undefined) {
                throw new RequiredError('modelCount','Required parameter modelCount was null or undefined when calling v1AiRecomputeSourceModelsModelCountPost.');
            }
            const localVarPath = `/v1/ai/recompute-source-models/{modelCount}`
                .replace(`{${"modelCount"}}`, encodeURIComponent(String(modelCount)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auto detect-anomalies
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnomaliesResponseDto> {
            const localVarFetchArgs = AIApiFetchParamCreator(configuration).v1AiAnomaliesSourceIdGet(sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecomputeDayModelsResponseDto> {
            const localVarFetchArgs = AIApiFetchParamCreator(configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecomputeDaysProjectionResponseDto> {
            const localVarFetchArgs = AIApiFetchParamCreator(configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year 
         * @param {number} sourceId 
         * @param {number} [modelCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year: number, sourceId: number, modelCount?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecomputeModelsResponseDto> {
            const localVarFetchArgs = AIApiFetchParamCreator(configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecomputeSourceModelsResponseDto> {
            const localVarFetchArgs = AIApiFetchParamCreator(configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Auto detect-anomalies
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiAnomaliesSourceIdGet(sourceId: number, options?: any) {
            return AIApiFp(configuration).v1AiAnomaliesSourceIdGet(sourceId, options)(fetch, basePath);
        },
        /**
         * Erases and re-computes all day models for a source and year
         * @summary Recomputes all day modesl
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDayModelsSourceIdYearPost(year: number, sourceId: number, options?: any) {
            return AIApiFp(configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * This computes the X/Y projection of all days in the source for the given year
         * @summary Computes all days projection for a source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeDaysProjectionSourceIdYearPost(year: number, sourceId: number, options?: any) {
            return AIApiFp(configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * This operations erases both non-handled alerts and user previsions
         * @summary Triggers a model recompute
         * @param {number} year 
         * @param {number} sourceId 
         * @param {number} [modelCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeModelsSourceIdYearPost(year: number, sourceId: number, modelCount?: number, options?: any) {
            return AIApiFp(configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options)(fetch, basePath);
        },
        /**
         * This operations erases the group configuration
         * @summary Triggers a model recompute for source groups
         * @param {number} modelCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AiRecomputeSourceModelsModelCountPost(modelCount: number, options?: any) {
            return AIApiFp(configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options)(fetch, basePath);
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * 
     * @summary Auto detect-anomalies
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public v1AiAnomaliesSourceIdGet(sourceId: number, options?: any) {
        return AIApiFp(this.configuration).v1AiAnomaliesSourceIdGet(sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * Erases and re-computes all day models for a source and year
     * @summary Recomputes all day modesl
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public v1AiRecomputeDayModelsSourceIdYearPost(year: number, sourceId: number, options?: any) {
        return AIApiFp(this.configuration).v1AiRecomputeDayModelsSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * This computes the X/Y projection of all days in the source for the given year
     * @summary Computes all days projection for a source and save them
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public v1AiRecomputeDaysProjectionSourceIdYearPost(year: number, sourceId: number, options?: any) {
        return AIApiFp(this.configuration).v1AiRecomputeDaysProjectionSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * This operations erases both non-handled alerts and user previsions
     * @summary Triggers a model recompute
     * @param {number} year 
     * @param {number} sourceId 
     * @param {number} [modelCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public v1AiRecomputeModelsSourceIdYearPost(year: number, sourceId: number, modelCount?: number, options?: any) {
        return AIApiFp(this.configuration).v1AiRecomputeModelsSourceIdYearPost(year, sourceId, modelCount, options)(this.fetch, this.basePath);
    }

    /**
     * This operations erases the group configuration
     * @summary Triggers a model recompute for source groups
     * @param {number} modelCount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public v1AiRecomputeSourceModelsModelCountPost(modelCount: number, options?: any) {
        return AIApiFp(this.configuration).v1AiRecomputeSourceModelsModelCountPost(modelCount, options)(this.fetch, this.basePath);
    }

}

/**
 * AlertApi - fetch parameter creator
 * @export
 */
export const AlertApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto: AlertCommentDto, alertId: number, options: any = {}): FetchArgs {
            // verify required parameter 'AlertCommentDto' is not null or undefined
            if (AlertCommentDto === null || AlertCommentDto === undefined) {
                throw new RequiredError('AlertCommentDto','Required parameter AlertCommentDto was null or undefined when calling v1AlertAlertIdCommentPatch.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId','Required parameter alertId was null or undefined when calling v1AlertAlertIdCommentPatch.');
            }
            const localVarPath = `/v1/alert/{alertId}/comment`
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlertCommentDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(AlertCommentDto || {}) : (AlertCommentDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto: AlertFavoriteDto, alertId: number, options: any = {}): FetchArgs {
            // verify required parameter 'AlertFavoriteDto' is not null or undefined
            if (AlertFavoriteDto === null || AlertFavoriteDto === undefined) {
                throw new RequiredError('AlertFavoriteDto','Required parameter AlertFavoriteDto was null or undefined when calling v1AlertAlertIdFavoritePatch.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId','Required parameter alertId was null or undefined when calling v1AlertAlertIdFavoritePatch.');
            }
            const localVarPath = `/v1/alert/{alertId}/favorite`
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AlertFavoriteDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(AlertFavoriteDto || {}) : (AlertFavoriteDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId?: number, year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/alert/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId?: number, year?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/alert/ref/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto: AlertCommentDto, alertId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertRefDto> {
            const localVarFetchArgs = AlertApiFetchParamCreator(configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto: AlertFavoriteDto, alertId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertDto> {
            const localVarFetchArgs = AlertApiFetchParamCreator(configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId?: number, year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertListDto> {
            const localVarFetchArgs = AlertApiFetchParamCreator(configuration).v1AlertListGet(sourceId, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId?: number, year?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertRefListDto> {
            const localVarFetchArgs = AlertApiFetchParamCreator(configuration).v1AlertRefListGet(sourceId, year, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A commented alert is closed and is moved to the alert referential
         * @summary Add a comment to an alert
         * @param {AlertCommentDto} AlertCommentDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdCommentPatch(AlertCommentDto: AlertCommentDto, alertId: number, options?: any) {
            return AlertApiFp(configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set alert favorite for the current user
         * @param {AlertFavoriteDto} AlertFavoriteDto 
         * @param {number} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertAlertIdFavoritePatch(AlertFavoriteDto: AlertFavoriteDto, alertId: number, options?: any) {
            return AlertApiFp(configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertListGet(sourceId?: number, year?: number, options?: any) {
            return AlertApiFp(configuration).v1AlertListGet(sourceId, year, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List alerts data of the selected year, all alerts if no year is provided
         * @param {number} [sourceId] 
         * @param {number} [year] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AlertRefListGet(sourceId?: number, year?: number, options?: any) {
            return AlertApiFp(configuration).v1AlertRefListGet(sourceId, year, options)(fetch, basePath);
        },
    };
};

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI {
    /**
     * A commented alert is closed and is moved to the alert referential
     * @summary Add a comment to an alert
     * @param {AlertCommentDto} AlertCommentDto 
     * @param {number} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public v1AlertAlertIdCommentPatch(AlertCommentDto: AlertCommentDto, alertId: number, options?: any) {
        return AlertApiFp(this.configuration).v1AlertAlertIdCommentPatch(AlertCommentDto, alertId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set alert favorite for the current user
     * @param {AlertFavoriteDto} AlertFavoriteDto 
     * @param {number} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public v1AlertAlertIdFavoritePatch(AlertFavoriteDto: AlertFavoriteDto, alertId: number, options?: any) {
        return AlertApiFp(this.configuration).v1AlertAlertIdFavoritePatch(AlertFavoriteDto, alertId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List alerts data of the selected year, all alerts if no year is provided
     * @param {number} [sourceId] 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public v1AlertListGet(sourceId?: number, year?: number, options?: any) {
        return AlertApiFp(this.configuration).v1AlertListGet(sourceId, year, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List alerts data of the selected year, all alerts if no year is provided
     * @param {number} [sourceId] 
     * @param {number} [year] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public v1AlertRefListGet(sourceId?: number, year?: number, options?: any) {
        return AlertApiFp(this.configuration).v1AlertRefListGet(sourceId, year, options)(this.fetch, this.basePath);
    }

}

/**
 * DayApi - fetch parameter creator
 * @export
 */
export const DayApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto: DaysPatchDto, options: any = {}): FetchArgs {
            // verify required parameter 'DaysPatchDto' is not null or undefined
            if (DaysPatchDto === null || DaysPatchDto === undefined) {
                throw new RequiredError('DaysPatchDto','Required parameter DaysPatchDto was null or undefined when calling v1DayBulkPatch.');
            }
            const localVarPath = `/v1/day/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DaysPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DaysPatchDto || {}) : (DaysPatchDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List day data of the reference year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1DayListSourceIdYearGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1DayListSourceIdYearGet.');
            }
            const localVarPath = `/v1/day/list/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DayApi - functional programming interface
 * @export
 */
export const DayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto: DaysPatchDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayListDto> {
            const localVarFetchArgs = DayApiFetchParamCreator(configuration).v1DayBulkPatch(DaysPatchDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List day data of the reference year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayListDto> {
            const localVarFetchArgs = DayApiFetchParamCreator(configuration).v1DayListSourceIdYearGet(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DayApi - factory interface
 * @export
 */
export const DayApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Update day entities
         * @param {DaysPatchDto} DaysPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayBulkPatch(DaysPatchDto: DaysPatchDto, options?: any) {
            return DayApiFp(configuration).v1DayBulkPatch(DaysPatchDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List day data of the reference year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayListSourceIdYearGet(year: number, sourceId: number, options?: any) {
            return DayApiFp(configuration).v1DayListSourceIdYearGet(year, sourceId, options)(fetch, basePath);
        },
    };
};

/**
 * DayApi - object-oriented interface
 * @export
 * @class DayApi
 * @extends {BaseAPI}
 */
export class DayApi extends BaseAPI {
    /**
     * 
     * @summary Update day entities
     * @param {DaysPatchDto} DaysPatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayApi
     */
    public v1DayBulkPatch(DaysPatchDto: DaysPatchDto, options?: any) {
        return DayApiFp(this.configuration).v1DayBulkPatch(DaysPatchDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List day data of the reference year
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayApi
     */
    public v1DayListSourceIdYearGet(year: number, sourceId: number, options?: any) {
        return DayApiFp(this.configuration).v1DayListSourceIdYearGet(year, sourceId, options)(this.fetch, this.basePath);
    }

}

/**
 * DayContextApi - fetch parameter creator
 * @export
 */
export const DayContextApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto: GeneratedDayContextBulkDto, options: any = {}): FetchArgs {
            // verify required parameter 'GeneratedDayContextBulkDto' is not null or undefined
            if (GeneratedDayContextBulkDto === null || GeneratedDayContextBulkDto === undefined) {
                throw new RequiredError('GeneratedDayContextBulkDto','Required parameter GeneratedDayContextBulkDto was null or undefined when calling v1DayContextBulkPost.');
            }
            const localVarPath = `/v1/day-context/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GeneratedDayContextBulkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(GeneratedDayContextBulkDto || {}) : (GeneratedDayContextBulkDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/day-context`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (or !== undefined) {
                localVarQueryParameter['or'] = or;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (per_page !== undefined) {
                localVarQueryParameter['per_page'] = per_page;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one DayContext
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayContextIdDelete.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve one DayContext
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id: number, fields?: string, join?: string, cache?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayContextIdGet.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext: DayContext, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext','Required parameter DayContext was null or undefined when calling v1DayContextIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayContextIdPatch.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext: DayContext, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext','Required parameter DayContext was null or undefined when calling v1DayContextIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayContextIdPut.');
            }
            const localVarPath = `/v1/day-context/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1DayContextImportMeteoCsvSourceIdPost.');
            }
            const localVarPath = `/v1/day-context/import-meteo-csv/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create one DayContext
         * @param {DayContext} DayContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext: DayContext, options: any = {}): FetchArgs {
            // verify required parameter 'DayContext' is not null or undefined
            if (DayContext === null || DayContext === undefined) {
                throw new RequiredError('DayContext','Required parameter DayContext was null or undefined when calling v1DayContextPost.');
            }
            const localVarPath = `/v1/day-context`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayContext" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayContext || {}) : (DayContext || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DayContextApi - functional programming interface
 * @export
 */
export const DayContextApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto: GeneratedDayContextBulkDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayContext>> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayContext>> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete one DayContext
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayContext> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve one DayContext
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayContext> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextIdGet(id, fields, join, cache, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext: DayContext, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayContext> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextIdPatch(DayContext, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext: DayContext, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayContext> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextIdPut(DayContext, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create one DayContext
         * @param {DayContext} DayContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext: DayContext, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayContext> {
            const localVarFetchArgs = DayContextApiFetchParamCreator(configuration).v1DayContextPost(DayContext, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DayContextApi - factory interface
 * @export
 */
export const DayContextApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create many DayContext
         * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextBulkPost(GeneratedDayContextBulkDto: GeneratedDayContextBulkDto, options?: any) {
            return DayContextApiFp(configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve many DayContext
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete one DayContext
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdDelete(id: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve one DayContext
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextIdGet(id, fields, join, cache, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPatch(DayContext: DayContext, id: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextIdPatch(DayContext, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace one DayContext
         * @param {DayContext} DayContext 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextIdPut(DayContext: DayContext, id: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextIdPut(DayContext, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Imports a meteo csv file for the source id
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextImportMeteoCsvSourceIdPost(sourceId: number, options?: any) {
            return DayContextApiFp(configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create one DayContext
         * @param {DayContext} DayContext 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayContextPost(DayContext: DayContext, options?: any) {
            return DayContextApiFp(configuration).v1DayContextPost(DayContext, options)(fetch, basePath);
        },
    };
};

/**
 * DayContextApi - object-oriented interface
 * @export
 * @class DayContextApi
 * @extends {BaseAPI}
 */
export class DayContextApi extends BaseAPI {
    /**
     * 
     * @summary Create many DayContext
     * @param {GeneratedDayContextBulkDto} GeneratedDayContextBulkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextBulkPost(GeneratedDayContextBulkDto: GeneratedDayContextBulkDto, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextBulkPost(GeneratedDayContextBulkDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve many DayContext
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
     * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
     * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
     * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete one DayContext
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextIdDelete(id: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve one DayContext
     * @param {number} id 
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextIdGet(id, fields, join, cache, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update one DayContext
     * @param {DayContext} DayContext 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextIdPatch(DayContext: DayContext, id: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextIdPatch(DayContext, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace one DayContext
     * @param {DayContext} DayContext 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextIdPut(DayContext: DayContext, id: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextIdPut(DayContext, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Imports a meteo csv file for the source id
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextImportMeteoCsvSourceIdPost(sourceId: number, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextImportMeteoCsvSourceIdPost(sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create one DayContext
     * @param {DayContext} DayContext 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayContextApi
     */
    public v1DayContextPost(DayContext: DayContext, options?: any) {
        return DayContextApiFp(this.configuration).v1DayContextPost(DayContext, options)(this.fetch, this.basePath);
    }

}

/**
 * DayTrendApi - fetch parameter creator
 * @export
 */
export const DayTrendApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto: GeneratedDayTrendBulkDto, options: any = {}): FetchArgs {
            // verify required parameter 'GeneratedDayTrendBulkDto' is not null or undefined
            if (GeneratedDayTrendBulkDto === null || GeneratedDayTrendBulkDto === undefined) {
                throw new RequiredError('GeneratedDayTrendBulkDto','Required parameter GeneratedDayTrendBulkDto was null or undefined when calling v1DayTrendBulkPost.');
            }
            const localVarPath = `/v1/day-trend/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GeneratedDayTrendBulkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(GeneratedDayTrendBulkDto || {}) : (GeneratedDayTrendBulkDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options: any = {}): FetchArgs {
            const localVarPath = `/v1/day-trend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (or !== undefined) {
                localVarQueryParameter['or'] = or;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (per_page !== undefined) {
                localVarQueryParameter['per_page'] = per_page;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one DayTrend
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayTrendIdDelete.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve one DayTrend
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id: number, fields?: string, join?: string, cache?: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayTrendIdGet.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (join !== undefined) {
                localVarQueryParameter['join'] = join;
            }

            if (cache !== undefined) {
                localVarQueryParameter['cache'] = cache;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend: DayTrend, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend','Required parameter DayTrend was null or undefined when calling v1DayTrendIdPatch.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayTrendIdPatch.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend: DayTrend, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend','Required parameter DayTrend was null or undefined when calling v1DayTrendIdPut.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling v1DayTrendIdPut.');
            }
            const localVarPath = `/v1/day-trend/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend: DayTrend, options: any = {}): FetchArgs {
            // verify required parameter 'DayTrend' is not null or undefined
            if (DayTrend === null || DayTrend === undefined) {
                throw new RequiredError('DayTrend','Required parameter DayTrend was null or undefined when calling v1DayTrendPost.');
            }
            const localVarPath = `/v1/day-trend`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayTrend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayTrend || {}) : (DayTrend || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId 
         * @param {DayTrendInputListDto} DayTrendInputListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId: number, DayTrendInputListDto: DayTrendInputListDto, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1DayTrendReplaceAllInSourceSourceIdPost.');
            }
            // verify required parameter 'DayTrendInputListDto' is not null or undefined
            if (DayTrendInputListDto === null || DayTrendInputListDto === undefined) {
                throw new RequiredError('DayTrendInputListDto','Required parameter DayTrendInputListDto was null or undefined when calling v1DayTrendReplaceAllInSourceSourceIdPost.');
            }
            const localVarPath = `/v1/day-trend/replace-all-in-source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DayTrendInputListDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(DayTrendInputListDto || {}) : (DayTrendInputListDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DayTrendApi - functional programming interface
 * @export
 */
export const DayTrendApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto: GeneratedDayTrendBulkDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayTrend>> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DayTrend>> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete one DayTrend
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrend> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendIdDelete(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve one DayTrend
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrend> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendIdGet(id, fields, join, cache, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend: DayTrend, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrend> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendIdPatch(DayTrend, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend: DayTrend, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrend> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendIdPut(DayTrend, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend: DayTrend, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrend> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendPost(DayTrend, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId 
         * @param {DayTrendInputListDto} DayTrendInputListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId: number, DayTrendInputListDto: DayTrendInputListDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DayTrendListDto> {
            const localVarFetchArgs = DayTrendApiFetchParamCreator(configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DayTrendApi - factory interface
 * @export
 */
export const DayTrendApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create many DayTrend
         * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendBulkPost(GeneratedDayTrendBulkDto: GeneratedDayTrendBulkDto, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve many DayTrend
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
         * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
         * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
         * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete one DayTrend
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdDelete(id: number, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve one DayTrend
         * @param {number} id 
         * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
         * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
         * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendIdGet(id, fields, join, cache, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPatch(DayTrend: DayTrend, id: number, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendIdPatch(DayTrend, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendIdPut(DayTrend: DayTrend, id: number, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendIdPut(DayTrend, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create one DayTrend
         * @param {DayTrend} DayTrend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendPost(DayTrend: DayTrend, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendPost(DayTrend, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Imports many trends and replace existing. Recomputes alerts
         * @param {number} sourceId 
         * @param {DayTrendInputListDto} DayTrendInputListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1DayTrendReplaceAllInSourceSourceIdPost(sourceId: number, DayTrendInputListDto: DayTrendInputListDto, options?: any) {
            return DayTrendApiFp(configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options)(fetch, basePath);
        },
    };
};

/**
 * DayTrendApi - object-oriented interface
 * @export
 * @class DayTrendApi
 * @extends {BaseAPI}
 */
export class DayTrendApi extends BaseAPI {
    /**
     * 
     * @summary Create many DayTrend
     * @param {GeneratedDayTrendBulkDto} GeneratedDayTrendBulkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendBulkPost(GeneratedDayTrendBulkDto: GeneratedDayTrendBulkDto, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendBulkPost(GeneratedDayTrendBulkDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve many DayTrend
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [filter] &lt;h4&gt;Adds fields request condition (multiple conditions) to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?filter&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt; &lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;isVillain||eq||false&amp;filter&#x3D;city||eq||Arkham&lt;/strong&gt; (multiple filters are treated as a combination of AND type of conditions)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;shots||in||12,26&lt;/strong&gt; (some conditions accept multiple values separated by commas)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;power||isnull&lt;/strong&gt; (some conditions don&#39;t accept value)&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;Filter Conditions:&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&#x3D;&lt;/code&gt;, equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ne&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;!&#x3D;&lt;/code&gt;, not equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&lt;/code&gt;, greater than)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lt&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, lower that)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;gte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;gt;&#x3D;&lt;/code&gt;, greater than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;lte&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;&amp;lt;&#x3D;&lt;/code&gt;, lower than or equal)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE val%&lt;/code&gt;, starts with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;ends&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val&lt;/code&gt;, ends with)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;cont&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;LIKE %val%&lt;/code&gt;, contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;excl&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT LIKE %val%&lt;/code&gt;, not contains)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IN&lt;/code&gt;, in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notin&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;NOT IN&lt;/code&gt;, not in range, &lt;strong&gt;&lt;em&gt;accepts multiple values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;isnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NULL&lt;/code&gt;, is NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;notnull&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;IS NOT NULL&lt;/code&gt;, not NULL, &lt;strong&gt;&lt;em&gt;doesn&#39;t accept value&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;between&lt;/code&gt;&lt;/strong&gt; (&lt;code&gt;BETWEEN&lt;/code&gt;, between, &lt;strong&gt;&lt;em&gt;accepts two values&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [or] &lt;h4&gt;Adds &lt;code&gt;OR&lt;/code&gt; conditions to the request.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?or&#x3D;field||condition||value&lt;/strong&gt;&lt;br/&gt;It uses the same conditions as the filter parameter&lt;br/&gt;&lt;i&gt;Rules and &lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;If there is only &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as simple filter:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;multiple&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; present (without &lt;code&gt;filter&lt;/code&gt;) then it will be interpreted as a compination of &lt;code&gt;OR&lt;/code&gt; conditions, as follows:&lt;br&gt;&lt;code&gt;WHERE {or} OR {or} OR ...&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?or&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If there are &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; then it will be interpreted as &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE {filter} OR {or}&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;name||eq||batman&amp;or&#x3D;name||eq||joker&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;If present &lt;strong&gt;both&lt;/strong&gt; &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; in any amount (&lt;strong&gt;one&lt;/strong&gt; or &lt;strong&gt;miltiple&lt;/strong&gt; each) then both interpreted as a combitation of &lt;code&gt;AND&lt;/code&gt; conditions and compared with each other by &lt;code&gt;OR&lt;/code&gt; condition, as follows:&lt;br&gt;&lt;code&gt;WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)&lt;/code&gt;&lt;/li&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?filter&#x3D;type||eq||hero&amp;filter&#x3D;status||eq||alive&amp;or&#x3D;type||eq||villain&amp;or&#x3D;status||eq||dead&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;
     * @param {string} [sort] &lt;h4&gt;Adds sort by field (by multiple fields) and order to query result.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?sort&#x3D;field,ASC|DESC&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?sort&#x3D;name,ASC&amp;sort&#x3D;id,DESC&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [per_page] &lt;h4&gt;Receive &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?per_page&#x3D;10&lt;/strong&gt;
     * @param {number} [offset] &lt;h4&gt;Offset &lt;code&gt;N&lt;/code&gt; amount of entities.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?offset&#x3D;10&lt;/strong&gt;
     * @param {number} [page] &lt;h4&gt;Receive a portion of &lt;code&gt;limit&lt;/code&gt; entities (alternative to &lt;code&gt;offset&lt;/code&gt;). Will be applied if &lt;code&gt;limit&lt;/code&gt; is set up.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?page&#x3D;number&lt;/strong&gt;&lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?page&#x3D;2&lt;/strong&gt;
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendGet(fields?: string, filter?: string, or?: string, sort?: string, join?: string, per_page?: number, offset?: number, page?: number, cache?: number, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendGet(fields, filter, or, sort, join, per_page, offset, page, cache, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete one DayTrend
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendIdDelete(id: number, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve one DayTrend
     * @param {number} id 
     * @param {string} [fields] &lt;h4&gt;Selects fields that should be returned in the reponse body.&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;field1,field2,...&lt;/strong&gt; &lt;br/&gt;&lt;i&gt;Example:&lt;/i&gt; &lt;strong&gt;?fields&#x3D;email,name&lt;/strong&gt;
     * @param {string} [join] &lt;h4&gt;Receive joined relational objects in GET result (with all or selected fields).&lt;/h4&gt;&lt;i&gt;Syntax:&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation||field1,field2,...&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1||field11,field12,...&amp;join&#x3D;relation1.nested||field21,field22,...&amp;join&#x3D;...&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;&lt;i&gt;Examples:&lt;/i&gt;&lt;/i&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;profile||firstName,email&amp;join&#x3D;notifications||content&amp;join&#x3D;tasks&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;?join&#x3D;relation1&amp;join&#x3D;relation1.nested&amp;join&#x3D;relation1.nested.deepnested&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;strong&gt;&lt;i&gt;Notice:&lt;/i&gt;&lt;/strong&gt; &lt;code&gt;id&lt;/code&gt; field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.
     * @param {number} [cache] &lt;h4&gt;Reset cache (if was enabled) and receive entities from the DB.&lt;/h4&gt;&lt;i&gt;Usage:&lt;/i&gt; &lt;strong&gt;?cache&#x3D;0&lt;/strong&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendIdGet(id: number, fields?: string, join?: string, cache?: number, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendIdGet(id, fields, join, cache, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update one DayTrend
     * @param {DayTrend} DayTrend 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendIdPatch(DayTrend: DayTrend, id: number, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendIdPatch(DayTrend, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replace one DayTrend
     * @param {DayTrend} DayTrend 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendIdPut(DayTrend: DayTrend, id: number, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendIdPut(DayTrend, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create one DayTrend
     * @param {DayTrend} DayTrend 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendPost(DayTrend: DayTrend, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendPost(DayTrend, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Imports many trends and replace existing. Recomputes alerts
     * @param {number} sourceId 
     * @param {DayTrendInputListDto} DayTrendInputListDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayTrendApi
     */
    public v1DayTrendReplaceAllInSourceSourceIdPost(sourceId: number, DayTrendInputListDto: DayTrendInputListDto, options?: any) {
        return DayTrendApiFp(this.configuration).v1DayTrendReplaceAllInSourceSourceIdPost(sourceId, DayTrendInputListDto, options)(this.fetch, this.basePath);
    }

}

/**
 * ImportApi - fetch parameter creator
 * @export
 */
export const ImportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto: CreateSourceDto, options: any = {}): FetchArgs {
            // verify required parameter 'CreateSourceDto' is not null or undefined
            if (CreateSourceDto === null || CreateSourceDto === undefined) {
                throw new RequiredError('CreateSourceDto','Required parameter CreateSourceDto was null or undefined when calling v1ImportCreateSourcePost.');
            }
            const localVarPath = `/v1/import/create-source`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateSourceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(CreateSourceDto || {}) : (CreateSourceDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto: ImportDaysDto, options: any = {}): FetchArgs {
            // verify required parameter 'ImportDaysDto' is not null or undefined
            if (ImportDaysDto === null || ImportDaysDto === undefined) {
                throw new RequiredError('ImportDaysDto','Required parameter ImportDaysDto was null or undefined when calling v1ImportDaysPost.');
            }
            const localVarPath = `/v1/import/days`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ImportDaysDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ImportDaysDto || {}) : (ImportDaysDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1ImportReprocessDaysSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1ImportReprocessDaysSourceIdYearPost.');
            }
            const localVarPath = `/v1/import/reprocess-days/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId 
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId: number, ImportDaysDto: ImportDaysDto, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1ImportSourceIdDaysPost.');
            }
            // verify required parameter 'ImportDaysDto' is not null or undefined
            if (ImportDaysDto === null || ImportDaysDto === undefined) {
                throw new RequiredError('ImportDaysDto','Required parameter ImportDaysDto was null or undefined when calling v1ImportSourceIdDaysPost.');
            }
            const localVarPath = `/v1/import/{sourceId}/days`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ImportDaysDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ImportDaysDto || {}) : (ImportDaysDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportApi - functional programming interface
 * @export
 */
export const ImportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto: CreateSourceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImportApiFetchParamCreator(configuration).v1ImportCreateSourcePost(CreateSourceDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto: ImportDaysDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImportApiFetchParamCreator(configuration).v1ImportDaysPost(ImportDaysDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImportApiFetchParamCreator(configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId 
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId: number, ImportDaysDto: ImportDaysDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ImportApiFetchParamCreator(configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImportApi - factory interface
 * @export
 */
export const ImportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a source, add a first batch of day data, then computes the models for the first time.
         * @summary First source creation
         * @param {CreateSourceDto} CreateSourceDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportCreateSourcePost(CreateSourceDto: CreateSourceDto, options?: any) {
            return ImportApiFp(configuration).v1ImportCreateSourcePost(CreateSourceDto, options)(fetch, basePath);
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportDaysPost(ImportDaysDto: ImportDaysDto, options?: any) {
            return ImportApiFp(configuration).v1ImportDaysPost(ImportDaysDto, options)(fetch, basePath);
        },
        /**
         * Compute maps, alerts and closest models
         * @summary Reprocess days from database
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportReprocessDaysSourceIdYearPost(year: number, sourceId: number, options?: any) {
            return ImportApiFp(configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * When new data is added, we compute alerts for this data
         * @summary Add new data to a source
         * @param {number} sourceId 
         * @param {ImportDaysDto} ImportDaysDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ImportSourceIdDaysPost(sourceId: number, ImportDaysDto: ImportDaysDto, options?: any) {
            return ImportApiFp(configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options)(fetch, basePath);
        },
    };
};

/**
 * ImportApi - object-oriented interface
 * @export
 * @class ImportApi
 * @extends {BaseAPI}
 */
export class ImportApi extends BaseAPI {
    /**
     * Creates a source, add a first batch of day data, then computes the models for the first time.
     * @summary First source creation
     * @param {CreateSourceDto} CreateSourceDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public v1ImportCreateSourcePost(CreateSourceDto: CreateSourceDto, options?: any) {
        return ImportApiFp(this.configuration).v1ImportCreateSourcePost(CreateSourceDto, options)(this.fetch, this.basePath);
    }

    /**
     * When new data is added, we compute alerts for this data
     * @summary Add new data to a source
     * @param {ImportDaysDto} ImportDaysDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public v1ImportDaysPost(ImportDaysDto: ImportDaysDto, options?: any) {
        return ImportApiFp(this.configuration).v1ImportDaysPost(ImportDaysDto, options)(this.fetch, this.basePath);
    }

    /**
     * Compute maps, alerts and closest models
     * @summary Reprocess days from database
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public v1ImportReprocessDaysSourceIdYearPost(year: number, sourceId: number, options?: any) {
        return ImportApiFp(this.configuration).v1ImportReprocessDaysSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * When new data is added, we compute alerts for this data
     * @summary Add new data to a source
     * @param {number} sourceId 
     * @param {ImportDaysDto} ImportDaysDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportApi
     */
    public v1ImportSourceIdDaysPost(sourceId: number, ImportDaysDto: ImportDaysDto, options?: any) {
        return ImportApiFp(this.configuration).v1ImportSourceIdDaysPost(sourceId, ImportDaysDto, options)(this.fetch, this.basePath);
    }

}

/**
 * ModelApi - fetch parameter creator
 * @export
 */
export const ModelApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto: ModelsPatchDto, options: any = {}): FetchArgs {
            // verify required parameter 'ModelsPatchDto' is not null or undefined
            if (ModelsPatchDto === null || ModelsPatchDto === undefined) {
                throw new RequiredError('ModelsPatchDto','Required parameter ModelsPatchDto was null or undefined when calling v1ModelBulkPatch.');
            }
            const localVarPath = `/v1/model/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ModelsPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(ModelsPatchDto || {}) : (ModelsPatchDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List models data of this source
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1ModelListSourceIdGet.');
            }
            const localVarPath = `/v1/model/list/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelApi - functional programming interface
 * @export
 */
export const ModelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto: ModelsPatchDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelListDto> {
            const localVarFetchArgs = ModelApiFetchParamCreator(configuration).v1ModelBulkPatch(ModelsPatchDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List models data of this source
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelListDto> {
            const localVarFetchArgs = ModelApiFetchParamCreator(configuration).v1ModelListSourceIdGet(sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModelApi - factory interface
 * @export
 */
export const ModelApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Update many models at once, mainly used to set color and name of the model
         * @summary Model bulk update
         * @param {ModelsPatchDto} ModelsPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelBulkPatch(ModelsPatchDto: ModelsPatchDto, options?: any) {
            return ModelApiFp(configuration).v1ModelBulkPatch(ModelsPatchDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List models data of this source
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ModelListSourceIdGet(sourceId: number, options?: any) {
            return ModelApiFp(configuration).v1ModelListSourceIdGet(sourceId, options)(fetch, basePath);
        },
    };
};

/**
 * ModelApi - object-oriented interface
 * @export
 * @class ModelApi
 * @extends {BaseAPI}
 */
export class ModelApi extends BaseAPI {
    /**
     * Update many models at once, mainly used to set color and name of the model
     * @summary Model bulk update
     * @param {ModelsPatchDto} ModelsPatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public v1ModelBulkPatch(ModelsPatchDto: ModelsPatchDto, options?: any) {
        return ModelApiFp(this.configuration).v1ModelBulkPatch(ModelsPatchDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List models data of this source
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelApi
     */
    public v1ModelListSourceIdGet(sourceId: number, options?: any) {
        return ModelApiFp(this.configuration).v1ModelListSourceIdGet(sourceId, options)(this.fetch, this.basePath);
    }

}

/**
 * PrevisionApi - fetch parameter creator
 * @export
 */
export const PrevisionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto: PrevisionApplyGroupDto, options: any = {}): FetchArgs {
            // verify required parameter 'PrevisionApplyGroupDto' is not null or undefined
            if (PrevisionApplyGroupDto === null || PrevisionApplyGroupDto === undefined) {
                throw new RequiredError('PrevisionApplyGroupDto','Required parameter PrevisionApplyGroupDto was null or undefined when calling v1PrevisionGroupApplyPrevisionPost.');
            }
            const localVarPath = `/v1/prevision/group-apply-prevision`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PrevisionApplyGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(PrevisionApplyGroupDto || {}) : (PrevisionApplyGroupDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch data previsions for a given year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1PrevisionListSourceIdYearGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1PrevisionListSourceIdYearGet.');
            }
            const localVarPath = `/v1/prevision/list/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate default previsions for the source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year: number, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling v1PrevisionSaveDefaultPrevisionsSourceIdYearPost.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1PrevisionSaveDefaultPrevisionsSourceIdYearPost.');
            }
            const localVarPath = `/v1/prevision/save-default-previsions/{sourceId}/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto: PrevisionBulkSaveDto, options: any = {}): FetchArgs {
            // verify required parameter 'PrevisionBulkSaveDto' is not null or undefined
            if (PrevisionBulkSaveDto === null || PrevisionBulkSaveDto === undefined) {
                throw new RequiredError('PrevisionBulkSaveDto','Required parameter PrevisionBulkSaveDto was null or undefined when calling v1PrevisionSavePost.');
            }
            const localVarPath = `/v1/prevision/save`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PrevisionBulkSaveDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(PrevisionBulkSaveDto || {}) : (PrevisionBulkSaveDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto: PrevisionPatchDto, options: any = {}): FetchArgs {
            // verify required parameter 'PrevisionPatchDto' is not null or undefined
            if (PrevisionPatchDto === null || PrevisionPatchDto === undefined) {
                throw new RequiredError('PrevisionPatchDto','Required parameter PrevisionPatchDto was null or undefined when calling v1PrevisionUpdatePatch.');
            }
            const localVarPath = `/v1/prevision/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PrevisionPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(PrevisionPatchDto || {}) : (PrevisionPatchDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrevisionApi - functional programming interface
 * @export
 */
export const PrevisionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto: PrevisionApplyGroupDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevisionApplyGroupResponseDto> {
            const localVarFetchArgs = PrevisionApiFetchParamCreator(configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetch data previsions for a given year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevisionListDto> {
            const localVarFetchArgs = PrevisionApiFetchParamCreator(configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Generate default previsions for the source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year: number, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevisionBulkSaveResultDto> {
            const localVarFetchArgs = PrevisionApiFetchParamCreator(configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto: PrevisionBulkSaveDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevisionBulkSaveResultDto> {
            const localVarFetchArgs = PrevisionApiFetchParamCreator(configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto: PrevisionPatchDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PrevisionUpdateResultDto> {
            const localVarFetchArgs = PrevisionApiFetchParamCreator(configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PrevisionApi - factory interface
 * @export
 */
export const PrevisionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Apply a source prevision to the whole group
         * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto: PrevisionApplyGroupDto, options?: any) {
            return PrevisionApiFp(configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetch data previsions for a given year
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionListSourceIdYearGet(year: number, sourceId: number, options?: any) {
            return PrevisionApiFp(configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generate default previsions for the source and save them
         * @param {number} year 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year: number, sourceId: number, options?: any) {
            return PrevisionApiFp(configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Save many previsions at once
         * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionSavePost(PrevisionBulkSaveDto: PrevisionBulkSaveDto, options?: any) {
            return PrevisionApiFp(configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a specific prevision
         * @param {PrevisionPatchDto} PrevisionPatchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1PrevisionUpdatePatch(PrevisionPatchDto: PrevisionPatchDto, options?: any) {
            return PrevisionApiFp(configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options)(fetch, basePath);
        },
    };
};

/**
 * PrevisionApi - object-oriented interface
 * @export
 * @class PrevisionApi
 * @extends {BaseAPI}
 */
export class PrevisionApi extends BaseAPI {
    /**
     * 
     * @summary Apply a source prevision to the whole group
     * @param {PrevisionApplyGroupDto} PrevisionApplyGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    public v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto: PrevisionApplyGroupDto, options?: any) {
        return PrevisionApiFp(this.configuration).v1PrevisionGroupApplyPrevisionPost(PrevisionApplyGroupDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetch data previsions for a given year
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    public v1PrevisionListSourceIdYearGet(year: number, sourceId: number, options?: any) {
        return PrevisionApiFp(this.configuration).v1PrevisionListSourceIdYearGet(year, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Generate default previsions for the source and save them
     * @param {number} year 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    public v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year: number, sourceId: number, options?: any) {
        return PrevisionApiFp(this.configuration).v1PrevisionSaveDefaultPrevisionsSourceIdYearPost(year, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Save many previsions at once
     * @param {PrevisionBulkSaveDto} PrevisionBulkSaveDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    public v1PrevisionSavePost(PrevisionBulkSaveDto: PrevisionBulkSaveDto, options?: any) {
        return PrevisionApiFp(this.configuration).v1PrevisionSavePost(PrevisionBulkSaveDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a specific prevision
     * @param {PrevisionPatchDto} PrevisionPatchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrevisionApi
     */
    public v1PrevisionUpdatePatch(PrevisionPatchDto: PrevisionPatchDto, options?: any) {
        return PrevisionApiFp(this.configuration).v1PrevisionUpdatePatch(PrevisionPatchDto, options)(this.fetch, this.basePath);
    }

}

/**
 * SourceApi - fetch parameter creator
 * @export
 */
export const SourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options: any = {}): FetchArgs {
            const localVarPath = `/v1/source/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a source and all linked data
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1SourceSourceIdDelete.');
            }
            const localVarPath = `/v1/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto: SourcePatchGroupDto, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'SourcePatchGroupDto' is not null or undefined
            if (SourcePatchGroupDto === null || SourcePatchGroupDto === undefined) {
                throw new RequiredError('SourcePatchGroupDto','Required parameter SourcePatchGroupDto was null or undefined when calling v1SourceSourceIdGroupPatch.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1SourceSourceIdGroupPatch.');
            }
            const localVarPath = `/v1/source/{sourceId}/group`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourcePatchGroupDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(SourcePatchGroupDto || {}) : (SourcePatchGroupDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto: SourcePatchDto, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'SourcePatchDto' is not null or undefined
            if (SourcePatchDto === null || SourcePatchDto === undefined) {
                throw new RequiredError('SourcePatchDto','Required parameter SourcePatchDto was null or undefined when calling v1SourceSourceIdPatch.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1SourceSourceIdPatch.');
            }
            const localVarPath = `/v1/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourcePatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(SourcePatchDto || {}) : (SourcePatchDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceApi - functional programming interface
 * @export
 */
export const SourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceListDto> {
            const localVarFetchArgs = SourceApiFetchParamCreator(configuration).v1SourceListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a source and all linked data
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SourceApiFetchParamCreator(configuration).v1SourceSourceIdDelete(sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto: SourcePatchGroupDto, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceDto> {
            const localVarFetchArgs = SourceApiFetchParamCreator(configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto: SourcePatchDto, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceDto> {
            const localVarFetchArgs = SourceApiFetchParamCreator(configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SourceApi - factory interface
 * @export
 */
export const SourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary All user sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceListGet(options?: any) {
            return SourceApiFp(configuration).v1SourceListGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a source and all linked data
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdDelete(sourceId: number, options?: any) {
            return SourceApiFp(configuration).v1SourceSourceIdDelete(sourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a source group
         * @param {SourcePatchGroupDto} SourcePatchGroupDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdGroupPatch(SourcePatchGroupDto: SourcePatchGroupDto, sourceId: number, options?: any) {
            return SourceApiFp(configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a source
         * @param {SourcePatchDto} SourcePatchDto 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceSourceIdPatch(SourcePatchDto: SourcePatchDto, sourceId: number, options?: any) {
            return SourceApiFp(configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options)(fetch, basePath);
        },
    };
};

/**
 * SourceApi - object-oriented interface
 * @export
 * @class SourceApi
 * @extends {BaseAPI}
 */
export class SourceApi extends BaseAPI {
    /**
     * 
     * @summary All user sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourceListGet(options?: any) {
        return SourceApiFp(this.configuration).v1SourceListGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a source and all linked data
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourceSourceIdDelete(sourceId: number, options?: any) {
        return SourceApiFp(this.configuration).v1SourceSourceIdDelete(sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a source group
     * @param {SourcePatchGroupDto} SourcePatchGroupDto 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourceSourceIdGroupPatch(SourcePatchGroupDto: SourcePatchGroupDto, sourceId: number, options?: any) {
        return SourceApiFp(this.configuration).v1SourceSourceIdGroupPatch(SourcePatchGroupDto, sourceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a source
     * @param {SourcePatchDto} SourcePatchDto 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceApi
     */
    public v1SourceSourceIdPatch(SourcePatchDto: SourcePatchDto, sourceId: number, options?: any) {
        return SourceApiFp(this.configuration).v1SourceSourceIdPatch(SourcePatchDto, sourceId, options)(this.fetch, this.basePath);
    }

}

/**
 * SourceGroupApi - fetch parameter creator
 * @export
 */
export const SourceGroupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto: SourceGroupCreateDto, options: any = {}): FetchArgs {
            // verify required parameter 'SourceGroupCreateDto' is not null or undefined
            if (SourceGroupCreateDto === null || SourceGroupCreateDto === undefined) {
                throw new RequiredError('SourceGroupCreateDto','Required parameter SourceGroupCreateDto was null or undefined when calling v1SourceGroupCreatePost.');
            }
            const localVarPath = `/v1/source-group/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourceGroupCreateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(SourceGroupCreateDto || {}) : (SourceGroupCreateDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto: SourceGroupPatchDto, groupId: number, options: any = {}): FetchArgs {
            // verify required parameter 'SourceGroupPatchDto' is not null or undefined
            if (SourceGroupPatchDto === null || SourceGroupPatchDto === undefined) {
                throw new RequiredError('SourceGroupPatchDto','Required parameter SourceGroupPatchDto was null or undefined when calling v1SourceGroupGroupIdPatch.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling v1SourceGroupGroupIdPatch.');
            }
            const localVarPath = `/v1/source-group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SourceGroupPatchDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(SourceGroupPatchDto || {}) : (SourceGroupPatchDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options: any = {}): FetchArgs {
            const localVarPath = `/v1/source-group/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceGroupApi - functional programming interface
 * @export
 */
export const SourceGroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto: SourceGroupCreateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceGroupDto> {
            const localVarFetchArgs = SourceGroupApiFetchParamCreator(configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto: SourceGroupPatchDto, groupId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceGroupDto> {
            const localVarFetchArgs = SourceGroupApiFetchParamCreator(configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SourceGroupListDto> {
            const localVarFetchArgs = SourceGroupApiFetchParamCreator(configuration).v1SourceGroupListGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SourceGroupApi - factory interface
 * @export
 */
export const SourceGroupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new source groups
         * @param {SourceGroupCreateDto} SourceGroupCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupCreatePost(SourceGroupCreateDto: SourceGroupCreateDto, options?: any) {
            return SourceGroupApiFp(configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a group configuration
         * @param {SourceGroupPatchDto} SourceGroupPatchDto 
         * @param {number} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupGroupIdPatch(SourceGroupPatchDto: SourceGroupPatchDto, groupId: number, options?: any) {
            return SourceGroupApiFp(configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary All source groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1SourceGroupListGet(options?: any) {
            return SourceGroupApiFp(configuration).v1SourceGroupListGet(options)(fetch, basePath);
        },
    };
};

/**
 * SourceGroupApi - object-oriented interface
 * @export
 * @class SourceGroupApi
 * @extends {BaseAPI}
 */
export class SourceGroupApi extends BaseAPI {
    /**
     * 
     * @summary Create a new source groups
     * @param {SourceGroupCreateDto} SourceGroupCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    public v1SourceGroupCreatePost(SourceGroupCreateDto: SourceGroupCreateDto, options?: any) {
        return SourceGroupApiFp(this.configuration).v1SourceGroupCreatePost(SourceGroupCreateDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a group configuration
     * @param {SourceGroupPatchDto} SourceGroupPatchDto 
     * @param {number} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    public v1SourceGroupGroupIdPatch(SourceGroupPatchDto: SourceGroupPatchDto, groupId: number, options?: any) {
        return SourceGroupApiFp(this.configuration).v1SourceGroupGroupIdPatch(SourceGroupPatchDto, groupId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary All source groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceGroupApi
     */
    public v1SourceGroupListGet(options?: any) {
        return SourceGroupApiFp(this.configuration).v1SourceGroupListGet(options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto: LoginDto, options: any = {}): FetchArgs {
            // verify required parameter 'LoginDto' is not null or undefined
            if (LoginDto === null || LoginDto === undefined) {
                throw new RequiredError('LoginDto','Required parameter LoginDto was null or undefined when calling v1UserLoginPost.');
            }
            const localVarPath = `/v1/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(LoginDto || {}) : (LoginDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options: any = {}): FetchArgs {
            const localVarPath = `/v1/user/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestDemoDto} RequestDemoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto: RequestDemoDto, options: any = {}): FetchArgs {
            // verify required parameter 'RequestDemoDto' is not null or undefined
            if (RequestDemoDto === null || RequestDemoDto === undefined) {
                throw new RequiredError('RequestDemoDto','Required parameter RequestDemoDto was null or undefined when calling v1UserRegisterDemoPost.');
            }
            const localVarPath = `/v1/user/register-demo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestDemoDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(RequestDemoDto || {}) : (RequestDemoDto || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto: LoginDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponseDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).v1UserLoginPost(LoginDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).v1UserMeGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RequestDemoDto} RequestDemoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto: RequestDemoDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponseDto> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).v1UserRegisterDemoPost(RequestDemoDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
         * @summary Log the user in
         * @param {LoginDto} LoginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserLoginPost(LoginDto: LoginDto, options?: any) {
            return UserApiFp(configuration).v1UserLoginPost(LoginDto, options)(fetch, basePath);
        },
        /**
         * Must be authenticated to call this endpoint
         * @summary Retrieve current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserMeGet(options?: any) {
            return UserApiFp(configuration).v1UserMeGet(options)(fetch, basePath);
        },
        /**
         * 
         * @param {RequestDemoDto} RequestDemoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1UserRegisterDemoPost(RequestDemoDto: RequestDemoDto, options?: any) {
            return UserApiFp(configuration).v1UserRegisterDemoPost(RequestDemoDto, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This endpoints returns the jwt and sets a cookie with the same jwt.      This way you can use it from both an api and a browser
     * @summary Log the user in
     * @param {LoginDto} LoginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UserLoginPost(LoginDto: LoginDto, options?: any) {
        return UserApiFp(this.configuration).v1UserLoginPost(LoginDto, options)(this.fetch, this.basePath);
    }

    /**
     * Must be authenticated to call this endpoint
     * @summary Retrieve current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UserMeGet(options?: any) {
        return UserApiFp(this.configuration).v1UserMeGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RequestDemoDto} RequestDemoDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public v1UserRegisterDemoPost(RequestDemoDto: RequestDemoDto, options?: any) {
        return UserApiFp(this.configuration).v1UserRegisterDemoPost(RequestDemoDto, options)(this.fetch, this.basePath);
    }

}

/**
 * ViewHelperApi - fetch parameter creator
 * @export
 */
export const ViewHelperApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options: any = {}): FetchArgs {
            const localVarPath = `/v1/view-helper/alerts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options: any = {}): FetchArgs {
            const localVarPath = `/v1/view-helper/alerts-ref`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the alert modal view data
         * @param {string} dayDate 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate: string, sourceId: number, options: any = {}): FetchArgs {
            // verify required parameter 'dayDate' is not null or undefined
            if (dayDate === null || dayDate === undefined) {
                throw new RequiredError('dayDate','Required parameter dayDate was null or undefined when calling v1ViewHelperDaysNearDateSourceIdDayDateGet.');
            }
            // verify required parameter 'sourceId' is not null or undefined
            if (sourceId === null || sourceId === undefined) {
                throw new RequiredError('sourceId','Required parameter sourceId was null or undefined when calling v1ViewHelperDaysNearDateSourceIdDayDateGet.');
            }
            const localVarPath = `/v1/view-helper/days-near-date/{sourceId}/{dayDate}`
                .replace(`{${"dayDate"}}`, encodeURIComponent(String(dayDate)))
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ViewHelperApi - functional programming interface
 * @export
 */
export const ViewHelperApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ViewHelperApiFetchParamCreator(configuration).v1ViewHelperAlertsGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlertRefResultDto> {
            const localVarFetchArgs = ViewHelperApiFetchParamCreator(configuration).v1ViewHelperAlertsRefGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the alert modal view data
         * @param {string} dayDate 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate: string, sourceId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DaysNearDateResultDto> {
            const localVarFetchArgs = ViewHelperApiFetchParamCreator(configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ViewHelperApi - factory interface
 * @export
 */
export const ViewHelperApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the alert view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsGet(options?: any) {
            return ViewHelperApiFp(configuration).v1ViewHelperAlertsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the alert referential view data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperAlertsRefGet(options?: any) {
            return ViewHelperApiFp(configuration).v1ViewHelperAlertsRefGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the alert modal view data
         * @param {string} dayDate 
         * @param {number} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate: string, sourceId: number, options?: any) {
            return ViewHelperApiFp(configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options)(fetch, basePath);
        },
    };
};

/**
 * ViewHelperApi - object-oriented interface
 * @export
 * @class ViewHelperApi
 * @extends {BaseAPI}
 */
export class ViewHelperApi extends BaseAPI {
    /**
     * 
     * @summary Get the alert view data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    public v1ViewHelperAlertsGet(options?: any) {
        return ViewHelperApiFp(this.configuration).v1ViewHelperAlertsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the alert referential view data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    public v1ViewHelperAlertsRefGet(options?: any) {
        return ViewHelperApiFp(this.configuration).v1ViewHelperAlertsRefGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the alert modal view data
     * @param {string} dayDate 
     * @param {number} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ViewHelperApi
     */
    public v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate: string, sourceId: number, options?: any) {
        return ViewHelperApiFp(this.configuration).v1ViewHelperDaysNearDateSourceIdDayDateGet(dayDate, sourceId, options)(this.fetch, this.basePath);
    }

}

